<?xml version="1.0" encoding="utf-8"?>
<!--03/23/2024
Bugs Framework (BF), BFCVE Tool, I. Bojanova, NIST, 2020-2024--><BFCVE_DAT-partial>
  <CVE CVE="CVE-2009-0586" CVSS="7.5">
    <Description>Integer overflow in the gst_vorbis_tag_add_coverart function (gst-libs/gst/tag/gstvorbistag.c) in vorbistag in gst-plugins-base (aka gstreamer-plugins-base) before 0.10.23 in GStreamer allows context-dependent attackers to execute arbitrary code via a crafted COVERART tag that is converted from a base64 representation, which triggers a heap-based buffer overflow.</Description>
    <URL>http://cgit.freedesktop.org/gstreamer/gst-plugins-base/commit/?id=566583e87147f774e7fc4c78b5f7e61d427e40a9</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2009-0946" CVSS="7.5">
    <Description>Multiple integer overflows in FreeType 2.3.9 and earlier allow remote attackers to execute arbitrary code via vectors related to large values in certain inputs in (1) smooth/ftsmooth.c, (2) sfnt/ttcmap.c, and (3) cff/cffload.c.</Description>
    <URL>http://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=0545ec1ca36b27cb928128870a83e5f668980bc5</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2009-1570" CVSS="9.3">
    <Description>Integer overflow in the ReadImage function in plug-ins/file-bmp/bmp-read.c in GIMP 2.6.7 might allow remote attackers to execute arbitrary code via a BMP file with crafted width and height values that trigger a heap-based buffer overflow.</Description>
    <URL>http://git.gnome.org/cgit/gimp/commit/?h=gimp-2-6&amp;id=df2b0aca2e7cdb95ebfd3454c65aaba0a83e9bbe</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2009-3909" CVSS="9.3">
    <Description>Integer overflow in the read_channel_data function in plug-ins/file-psd/psd-load.c in GIMP 2.6.7 might allow remote attackers to execute arbitrary code via a crafted PSD file that triggers a heap-based buffer overflow.</Description>
    <URL>http://git.gnome.org/cgit/gimp/commit/?id=0e440cb6d4d6ee029667363d244aff61b154c33c</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2010-2497" CVSS="6.8">
    <Description>Integer underflow in glyph handling in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.</Description>
    <URL>http://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7d3d2cc4fef72c6be9c454b3809c387e12b44cfc</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2010-2500" CVSS="6.8">
    <Description>Integer overflow in the gray_render_span function in smooth/ftgrays.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.</Description>
    <URL>http://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=6305b869d86ff415a33576df6d43729673c66eee</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2010-2807" CVSS="6.8">
    <Description>FreeType before 2.4.2 uses incorrect integer data types during bounds checking, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.</Description>
    <URL>http://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=346f1867fd32dae8f56e5b482d1af98f626804ac</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2010-5331" CVSS="7.8">
    <Description>In the Linux kernel before 2.6.34, a range check issue in drivers/gpu/drm/radeon/atombios.c could cause an off by one (buffer overflow) problem. NOTE: At least one Linux maintainer believes that this CVE is incorrectly assigned and should be rejected because the value is hard coded and are not user-controllable where it is used</Description>
    <URL>https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=0031c41be5c529f8329e327b63cde92ba1284842</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2011-1027" CVSS="5.0">
    <Description>Off-by-one error in the convert_query_hexchar function in html.c in cgit.cgi in cgit before 0.8.3.5 allows remote attackers to cause a denial of service (infinite loop) via a string composed of a % (percent) character followed by invalid hex characters, as demonstrated by a %gg sequence.</Description>
    <URL>http://hjemli.net/git/cgit/commit/?h=stable&amp;id=fc384b16fb9787380746000d3cea2d53fccc548e</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One, via Infinite Loop">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2011-1178" CVSS="6.8">
    <Description>Multiple integer overflows in the load_image function in file-pcx.c in the Personal Computer Exchange (PCX) plugin in GIMP 2.6.x and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PCX image that triggers a heap-based buffer overflow.</Description>
    <URL>http://git.gnome.org/browse/gimp/commit/?id=a9671395f6573e90316a9d748588c5435216f6ce</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2011-4097" CVSS="5.5">
    <Description>Integer overflow in the oom_badness function in mm/oom_kill.c in the Linux kernel before 3.1.8 on 64-bit platforms allows local users to cause a denial of service (memory consumption or process termination) by using a certain large amount of memory.</Description>
    <URL>https://github.com/torvalds/linux/commit/56c6a8a4aadca809e04276eabe5552935c51387f</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2012-0038" CVSS="5.5">
    <Description>Integer overflow in the xfs_acl_from_disk function in fs/xfs/xfs_acl.c in the Linux kernel before 3.1.9 allows local users to cause a denial of service (panic) via a filesystem with a malformed ACL, leading to a heap-based buffer overflow.</Description>
    <URL>https://github.com/torvalds/linux/commit/093019cf1b18dd31b2c3b77acce4e000e2cbc9ce</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2012-0044" CVSS="7.8">
    <Description>Integer overflow in the drm_mode_dirtyfb_ioctl function in drivers/gpu/drm/drm_crtc.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.1.5 allows local users to gain privileges or cause a denial of service (memory corruption) via a crafted ioctl call.</Description>
    <URL>https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
    <Failure Comment="via Gain Privilege">Impersonation (IMP)</Failure>
  </CVE>
  <CVE CVE="CVE-2012-0207" CVSS="7.5">
    <Description>The igmp_heard_query function in net/ipv4/igmp.c in the Linux kernel before 3.2.1 allows remote attackers to cause a denial of service (divide-by-zero error and panic) via IGMP packets.</Description>
    <URL>https://github.com/torvalds/linux/commit/25c413ad0029ea86008234be28aee33456e53e5b</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2012-6701" CVSS="7.8">
    <Description>Integer overflow in fs/aio.c in the Linux kernel before 3.4.1 allows local users to cause a denial of service or possibly have unspecified other impact via a large AIO iovec.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=a70b52ec1aaeaf60f4739edb1b422827cb6f3893</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2012-6703" CVSS="7.8">
    <Description>Integer overflow in the snd_compr_allocate_buffer function in sound/core/compress_offload.c in the ALSA subsystem in the Linux kernel before 3.6-rc6-next-20120917 allows local users to cause a denial of service (insufficient memory allocation) or possibly have unspecified other impact via a crafted SNDRV_COMPRESS_SET_PARAMS ioctl call.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=b35cc8225845112a616e3a2266d2fde5ab13d3ab</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2013-1591" CVSS="9.8">
    <Description>Stack-based buffer overflow in libpixman, as used in Pale Moon before 15.4 and possibly other products, has unspecified impact and context-dependent attack vectors.  NOTE: this issue might be resultant from an integer overflow in the fast_composite_scaled_bilinear function in pixman-inlines.h, which triggers an infinite loop.</Description>
    <URL>http://cgit.freedesktop.org/pixman/commit/?id=de60e2e0e3eb6084f8f14b63f25b3cbfb012943f</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Infinite Loop">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2013-4391" CVSS="7.5">
    <Description>Integer overflow in the valid_user_field function in journal/journald-native.c in systemd allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large journal data field, which triggers a heap-based buffer overflow.</Description>
    <URL>http://cgit.freedesktop.org/systemd/systemd/commit/?id=505b6a61c22d5565e9308045c7b9bf79f7d0517e</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2013-6425" CVSS="5.0">
    <Description>Integer underflow in the pixman_trapezoid_valid macro in pixman.h in Pixman before 0.32.0, as used in X.Org server and cairo, allows context-dependent attackers to cause a denial of service (crash) via a negative bottom value.</Description>
    <URL>http://cgit.freedesktop.org/pixman/commit/?id=5e14da97f16e421d084a9e735be21b1025150f0c</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2014-125057" CVSS="9.8">
    <Description>A vulnerability was found in mrobit robitailletheknot. It has been classified as problematic. This affects an unknown part of the file app/filters.php of the component CSRF Token Handler. The manipulation of the argument _token leads to incorrect comparison. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The patch is named 6b2813696ccb88d0576dfb305122ee880eb36197. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-217599.</Description>
    <URL>https://github.com/mrobit/robitailletheknot/commit/6b2813696ccb88d0576dfb305122ee880eb36197</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2014-3144" CVSS="4.9">
    <Description>The (1) BPF_S_ANC_NLATTR and (2) BPF_S_ANC_NLATTR_NEST extension implementations in the sk_run_filter function in net/core/filter.c in the Linux kernel through 3.14.3 do not check whether a certain length value is sufficiently large, which allows local users to cause a denial of service (integer underflow and system crash) via crafted BPF instructions.  NOTE: the affected code was moved to the __skb_get_nlattr and __skb_get_nlattr_nest functions before the vulnerability was announced.</Description>
    <URL>https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via System Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2014-3468" CVSS="7.5">
    <Description>The asn1_get_bit_der function in GNU Libtasn1 before 3.6 does not properly report an error when a negative bit length is identified, which allows context-dependent attackers to cause out-of-bounds access via crafted ASN.1 data.</Description>
    <URL>http://git.savannah.gnu.org/cgit/libtasn1.git/commit/?id=1c3ccb3e040bf13e342ee60bc23b21b97b11923f</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2014-4608" CVSS="7.5">
    <Description>Multiple integer overflows in the lzo1x_decompress_safe function in lib/lzo/lzo1x_decompress_safe.c in the LZO decompressor in the Linux kernel before 3.15.2 allow context-dependent attackers to cause a denial of service (memory corruption) via a crafted Literal Run.  NOTE: the author of the LZO algorithms says "the Linux kernel is *not* affected; media hype.</Description>
    <URL>https://github.com/torvalds/linux/commit/206a81c18401c0cde6e579164f752c4b147324ce</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2014-4655" CVSS="4.9">
    <Description>The snd_ctl_elem_add function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not properly maintain the user_ctl_count value, which allows local users to cause a denial of service (integer overflow and limit bypass) by leveraging /dev/snd/controlCX access for a large number of SNDRV_CTL_IOCTL_ELEM_REPLACE ioctl calls.</Description>
    <URL>https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2014-4656" CVSS="4.6">
    <Description>Multiple integer overflows in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 allow local users to cause a denial of service by leveraging /dev/snd/controlCX access, related to (1) index values in the snd_ctl_add function and (2) numid values in the snd_ctl_remove_numid_conflict function.</Description>
    <URL>https://github.com/torvalds/linux/commit/883a1d49f0d77d30012f114b2e19fc141beb3e8e</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2014-8130" CVSS="6.5">
    <Description>The _TIFFmalloc function in tif_unix.c in LibTIFF 4.0.3 does not reject a zero size, which allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted TIFF image that is mishandled by the TIFFWriteScanline function in tif_write.c, as demonstrated by tiffdither.</Description>
    <URL>https://github.com/vadz/libtiff/commit/3c5eb8b1be544e41d2c336191bc4936300ad7543</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2014-9626" CVSS="7.8">
    <Description>Integer underflow in the MP4_ReadBox_String function in modules/demux/mp4/libmp4.c in VideoLAN VLC media player before 2.1.6 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a box size less than 7.</Description>
    <URL>https://github.com/videolan/vlc/commit/2e7c7091a61aa5d07e7997b393d821e91f593c39</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2014-9756" CVSS="5.0">
    <Description>The psf_fwrite function in file_io.c in libsndfile allows attackers to cause a denial of service (divide-by-zero error and application crash) via unspecified vectors related to the headindex variable.</Description>
    <URL>https://github.com/erikd/libsndfile/commit/725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2014-9863" CVSS="7.8">
    <Description>Integer underflow in the diag driver in the Qualcomm components in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices allows attackers to gain privileges or obtain sensitive information via a crafted application, aka Android internal bug 28768146 and Qualcomm internal bug CR549470.</Description>
    <URL>https://source.codeaurora.org/quic/la/kernel/msm-3.10/commit/?id=75eac48a48562f819f50eeff8369b296d89102d7</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Gain Privilege">Impersonation (IMP)</Failure>
  </CVE>
  <CVE CVE="CVE-2014-9883" CVSS="7.8">
    <Description>Integer overflow in drivers/char/diag/diag_dci.c in the Qualcomm components in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices allows attackers to gain privileges or obtain sensitive information via a crafted application, aka Android internal bug 28769912 and Qualcomm internal bug CR565160.</Description>
    <URL>https://source.codeaurora.org/quic/la/kernel/msm/commit/?id=cbf79a67348e48557c0d0bb9bc58391b3f84bc46</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Gain Privilege">Impersonation (IMP)</Failure>
  </CVE>
  <CVE CVE="CVE-2015-10129" CVSS="5.9">
    <Description>A vulnerability was found in planet-freo up to 20150116 and classified as problematic. Affected by this issue is some unknown functionality of the file admin/inc/auth.inc.php. The manipulation of the argument auth leads to incorrect comparison. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. This product is using a rolling release to provide continious delivery. Therefore, no version details for affected nor updated releases are available. The name of the patch is 6ad38c58a45642eb8c7844e2f272ef199f59550d. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-252716.</Description>
    <URL>https://github.com/samwilson/planet-freo/commit/6ad38c58a45642eb8c7844e2f272ef199f59550d</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2015-2310" CVSS="9.1">
    <Description>Integer overflow in layout.c++ in Sandstorm Cap'n Proto before 0.4.1.1 and 0.5.x before 0.5.1.1 allows remote peers to cause a denial of service or possibly obtain sensitive information from memory via a crafted message, related to pointer validation.</Description>
    <URL>https://github.com/capnproto/capnproto/commit/f343f0dbd0a2e87f17cd74f14186ed73e3fbdbfa</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2015-2311" CVSS="9.8">
    <Description>Integer underflow in Sandstorm Cap'n Proto before 0.4.1.1 and 0.5.x before 0.5.1.1 might allow remote peers to cause a denial of service or possibly obtain sensitive information from memory or execute arbitrary code via a crafted message.</Description>
    <URL>https://github.com/capnproto/capnproto/commit/26bcceda72372211063d62aab7e45665faa83633</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2015-3406" CVSS="7.5">
    <Description>The PGP signature parsing in Module::Signature before 0.74 allows remote attackers to cause the unsigned portion of a SIGNATURE file to be treated as the signed portion via unspecified vectors.</Description>
    <URL>https://github.com/audreyt/module-signature/commit/8a9164596fa5952d4fbcde5aa1c7d1c7bc85372f</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2015-3418" CVSS="7.5">
    <Description>The ProcPutImage function in dix/dispatch.c in X.Org Server (aka xserver and xorg-server) before 1.16.4 allows attackers to cause a denial of service (divide-by-zero and crash) via a zero-height PutImage request.</Description>
    <URL>https://cgit.freedesktop.org/xorg/xserver/commit/?id=dc777c346d5d452a53b13b917c45f6a1bad2f20b</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2015-4042" CVSS="9.8">
    <Description>Integer overflow in the keycompare_mb function in sort.c in sort in GNU Coreutils through 8.23 might allow attackers to cause a denial of service (application crash) or possibly have unspecified other impact via long strings.</Description>
    <URL>https://github.com/pixelb/coreutils/commit/bea5e36cc876ed627bb5e0eca36fdfaa6465e940</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2015-4645" CVSS="5.5">
    <Description>Integer overflow in the read_fragment_table_4 function in unsquash-4.c in Squashfs and sasquatch allows remote attackers to cause a denial of service (application crash) via a crafted input, which triggers a stack-based buffer overflow.</Description>
    <URL>https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2015-5707" CVSS="4.6">
    <Description>Integer overflow in the sg_start_req function in drivers/scsi/sg.c in the Linux kernel 2.6.x through 4.x before 4.1 allows local users to cause a denial of service or possibly have unspecified other impact via a large iov_count value in a write request.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=451a2886b6bf90e2fb378f7c46c655450fb96e81</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2015-7513" CVSS="6.5">
    <Description>arch/x86/kvm/x86.c in the Linux kernel before 4.4 does not reset the PIT counter values during state restoration, which allows guest OS users to cause a denial of service (divide-by-zero error and host OS crash) via a zero value, related to the kvm_vm_ioctl_set_pit and kvm_vm_ioctl_set_pit2 functions.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=0185604c2d82c560dab2f2933a18f797e74ab5a8</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Host OS Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2015-8895" CVSS="7.5">
    <Description>Integer overflow in coders/icon.c in ImageMagick 6.9.1-3 and later allows remote attackers to cause a denial of service (application crash) via a crafted length value, which triggers a buffer overflow.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-10053" CVSS="5.5">
    <Description>The WriteTIFFImage function in coders/tiff.c in ImageMagick before 6.9.5-8 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted file.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/728dc6a600cf4cbdac846964c85cc04339db8ac1</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-10093" CVSS="7.8">
    <Description>Integer overflow in tools/tiffcp.c in LibTIFF 4.0.7, 3.9.3, 3.9.4, 3.9.5, 3.9.6, 3.9.7, 4.0.0alpha4, 4.0.0alpha5, 4.0.0alpha6, 4.0.0beta7, 4.0.0, 4.0.1, 4.0.2, 4.0.3, 4.0.4, 4.0.4beta, 4.0.5 and 4.0.6 allows remote attackers to have unspecified impact via a crafted image, which triggers a heap-based buffer overflow.</Description>
    <URL>https://github.com/vadz/libtiff/commit/787c0ee906430b772f33ca50b97b8b5ca070faec</URL>
    <CWE CWE="119">
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-10159" CVSS="7.5">
    <Description>Integer overflow in the phar_parse_pharfile function in ext/phar/phar.c in PHP before 5.6.30 and 7.0.x before 7.0.15 allows remote attackers to cause a denial of service (memory consumption or application crash) via a truncated manifest entry in a PHAR archive.</Description>
    <URL>https://github.com/php/php-src/commit/ca46d0acbce55019b970fcd4c1e8a10edfdded93</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-10160" CVSS="9.8">
    <Description>Off-by-one error in the phar_parse_pharfile function in ext/phar/phar.c in PHP before 5.6.30 and 7.0.x before 7.0.15 allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via a crafted PHAR archive with an alias mismatch.</Description>
    <URL>https://github.com/php/php-src/commit/b28b8b2fee6dfa6fcd13305c581bb835689ac3be</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-10164" CVSS="9.8">
    <Description>Multiple integer overflows in libXpm before 3.5.12, when a program requests parsing XPM extensions on a 64-bit platform, allow remote attackers to cause a denial of service (out-of-bounds write) or execute arbitrary code via (1) the number of extensions or (2) their concatenated length in a crafted XPM file, which triggers a heap-based buffer overflow.</Description>
    <URL>https://cgit.freedesktop.org/xorg/lib/libXpm/commit/?id=d1167418f0fd02a27f617ec5afd6db053afbe185</URL>
    <CWE CWE="119">
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-10166" CVSS="9.8">
    <Description>Integer underflow in the _gdContributionsAlloc function in gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via vectors related to decrementing the u variable.</Description>
    <URL>https://github.com/libgd/libgd/commit/60bfb401ad5a4a8ae995dcd36372fe15c71e1a35</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2016-10168" CVSS="7.8">
    <Description>Integer overflow in gd_io.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via vectors involving the number of horizontal and vertical chunks in an image.</Description>
    <URL>https://github.com/libgd/libgd/commit/69d2fd2c597ffc0c217de1238b9bf4d4bceba8e6</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2016-10249" CVSS="7.8">
    <Description>Integer overflow in the jpc_dec_tiledecode function in jpc_dec.c in JasPer before 1.900.12 allows remote attackers to have unspecified impact via a crafted image file, which triggers a heap-based buffer overflow.</Description>
    <URL>https://github.com/mdadams/jasper/commit/988f8365f7d8ad8073b6786e433d34c553ecf568</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-10251" CVSS="7.8">
    <Description>Integer overflow in the jpc_pi_nextcprl function in jpc_t2cod.c in JasPer before 1.900.20 allows remote attackers to have unspecified impact via a crafted file, which triggers use of an uninitialized value.</Description>
    <URL>https://github.com/mdadams/jasper/commit/1f0dfe5a42911b6880a1445f13f6d615ddb55387</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2016-10266" CVSS="5.5">
    <Description>LibTIFF 4.0.7 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted TIFF image, related to libtiff/tif_read.c:351:22.</Description>
    <URL>https://github.com/vadz/libtiff/commit/438274f938e046d33cb0e1230b41da32ffe223e1</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-10267" CVSS="5.5">
    <Description>LibTIFF 4.0.7 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted TIFF image, related to libtiff/tif_ojpeg.c:816:8.</Description>
    <URL>https://github.com/vadz/libtiff/commit/43bc256d8ae44b92d2734a3c5bc73957a4d7c1ec</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-10268" CVSS="7.8">
    <Description>tools/tiffcp.c in LibTIFF 4.0.7 allows remote attackers to cause a denial of service (integer underflow and heap-based buffer under-read) or possibly have unspecified other impact via a crafted TIFF image, related to "READ of size 78490" and libtiff/tif_unix.c:115:23.</Description>
    <URL>https://github.com/vadz/libtiff/commit/5397a417e61258c69209904e652a1f409ec3b9df</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-10506" CVSS="6.5">
    <Description>Division-by-zero vulnerabilities in the functions opj_pi_next_cprl, opj_pi_next_pcrl, and opj_pi_next_rpcl in pi.c in OpenJPEG before 2.2.0 allow remote attackers to cause a denial of service (application crash) via crafted j2k files.</Description>
    <URL>https://github.com/uclouvain/openjpeg/commit/d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-10507" CVSS="6.5">
    <Description>Integer overflow vulnerability in the bmp24toimage function in convertbmp.c in OpenJPEG before 2.2.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted bmp file.</Description>
    <URL>https://github.com/uclouvain/openjpeg/commit/da940424816e11d624362ce080bc026adffa26e8</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-2062" CVSS="7.8">
    <Description>The adreno_perfcounter_query_group function in drivers/gpu/msm/adreno_perfcounter.c in the Adreno GPU driver for the Linux kernel 3.x, as used in Qualcomm Innovation Center (QuIC) Android contributions for MSM devices and other products, uses an incorrect integer data type, which allows attackers to cause a denial of service (integer overflow, heap-based buffer overflow, and incorrect memory allocation) or possibly have unspecified other impact via a crafted IOCTL_KGSL_PERFCOUNTER_QUERY ioctl call.</Description>
    <URL>https://codeaurora.org/cgit/quic/la/kernel/msm-3.18/commit/?id=27c95b64b2e4b5ff1288cbaa6e353dd803d71576</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-2068" CVSS="7.8">
    <Description>The MSM QDSP6 audio driver (aka sound driver) for the Linux kernel 3.x, as used in Qualcomm Innovation Center (QuIC) Android contributions for MSM devices and other products, allows attackers to gain privileges or cause a denial of service (integer overflow, and buffer overflow or buffer over-read) via a crafted application that performs a (1) AUDIO_EFFECTS_WRITE or (2) AUDIO_EFFECTS_READ operation, aka Qualcomm internal bug CR1006609.</Description>
    <URL>https://source.codeaurora.org/quic/la/kernel/msm-3.10/commit/?id=01ee86da5a0cd788f134e360e2be517ef52b6b00</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
    <Failure Comment="via Gain Privilege">Impersonation (IMP)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-2147" CVSS="7.5">
    <Description>Integer overflow in the DHCP client (udhcpc) in BusyBox before 1.25.0 allows remote attackers to cause a denial of service (crash) via a malformed RFC1035-encoded domain name, which triggers an out-of-bounds heap write.</Description>
    <URL>https://git.busybox.net/busybox/commit/?id=d474ffc68290e0a83651c4432eeabfa62cd51e87</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-2347" CVSS="7.8">
    <Description>Integer underflow in the decode_level3_header function in lib/lha_file_header.c in Lhasa before 0.3.1 allows remote attackers to execute arbitrary code via a crafted archive.</Description>
    <URL>https://github.com/fragglet/lhasa/commit/6fcdb8f1f538b9d63e63a5fa199c5514a15d4564</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-3074" CVSS="9.8">
    <Description>Integer signedness error in GD Graphics Library 2.1.1 (aka libgd or libgd2) allows remote attackers to cause a denial of service (crash) or potentially execute arbitrary code via crafted compressed gd2 data, which triggers a heap-based buffer overflow.</Description>
    <URL>https://github.com/libgd/libgd/commit/2bb97f407c1145c850416a3bfbcc8cf124e68a19</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-3078" CVSS="9.8">
    <Description>Multiple integer overflows in php_zip.c in the zip extension in PHP before 7.0.6 allow remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted call to (1) getFromIndex or (2) getFromName in the ZipArchive class.</Description>
    <URL>https://github.com/php/php-src/commit/3b8d4de300854b3517c7acb239b84f7726c1353c?w=1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-3901" CVSS="7.8">
    <Description>Multiple integer overflows in drivers/crypto/msm/qcedev.c in the Qualcomm cryptographic engine driver in Android before 2016-10-05 on Nexus 5X, Nexus 6, Nexus 6P, and Android One devices allow attackers to gain privileges via a crafted application, aka Android internal bug 29999161 and Qualcomm internal bug CR 1046434.</Description>
    <URL>https://source.codeaurora.org/quic/la/kernel/msm-3.18/commit/?id=5f69ccf3b011c1d14a1b1b00dbaacf74307c9132</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Gain Privilege">Impersonation (IMP)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-3935" CVSS="7.8">
    <Description>Multiple integer overflows in drivers/crypto/msm/qcedev.c in the Qualcomm cryptographic engine driver in Android before 2016-10-05 on Nexus 5X, Nexus 6, Nexus 6P, and Android One devices allow attackers to gain privileges via a crafted application, aka Android internal bug 29999665 and Qualcomm internal bug CR 1046507.</Description>
    <URL>https://source.codeaurora.org/quic/la/kernel/msm-3.18/commit/?id=5f69ccf3b011c1d14a1b1b00dbaacf74307c9132</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Gain Privilege">Impersonation (IMP)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-4300" CVSS="7.8">
    <Description>Integer overflow in the read_SubStreamsInfo function in archive_read_support_format_7zip.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a 7zip file with a large number of substreams, which triggers a heap-based buffer overflow.</Description>
    <URL>https://github.com/libarchive/libarchive/commit/e79ef306afe332faf22e9b442a2c6b59cb175573</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-4797" CVSS="5.5">
    <Description>Divide-by-zero vulnerability in the opj_tcd_init_tile function in tcd.c in OpenJPEG before 2.1.1 allows remote attackers to cause a denial of service (application crash) via a crafted jp2 file. NOTE: this issue exists because of an incorrect fix for CVE-2014-7947.</Description>
    <URL>https://github.com/uclouvain/openjpeg/commit/8f9cc62b3f9a1da9712329ddcedb9750d585505c</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-5094" CVSS="8.6">
    <Description>Integer overflow in the php_html_entities function in ext/standard/html.c in PHP before 5.5.36 and 5.6.x before 5.6.22 allows remote attackers to cause a denial of service or possibly have unspecified other impact by triggering a large output string from the htmlspecialchars function.</Description>
    <URL>https://github.com/php/php-src/commit/0da8b8b801f9276359262f1ef8274c7812d3dfda?w=1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-5096" CVSS="8.6">
    <Description>Integer overflow in the fread function in ext/standard/file.c in PHP before 5.5.36 and 5.6.x before 5.6.22 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer in the second argument.</Description>
    <URL>https://github.com/php/php-src/commit/abd159cce48f3e34f08e4751c568e09677d5ec9c?w=1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-5344" CVSS="9.8">
    <Description>Multiple integer overflows in the MDSS driver for the Linux kernel 3.x, as used in Qualcomm Innovation Center (QuIC) Android contributions for MSM devices and other products, allow attackers to cause a denial of service or possibly have unspecified other impact via a large size value, related to mdss_compat_utils.c, mdss_fb.c, and mdss_rotator.c.</Description>
    <URL>https://source.codeaurora.org/quic/la/kernel/msm-3.18/commit/?id=1d2297267c24f2c44bd0ecb244ddb8bc880a29b7</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-5735" CVSS="7.8">
    <Description>Integer overflow in the rwpng_read_image24_libpng function in rwpng.c in pngquant 2.7.0 allows remote attackers to have unspecified impact via a crafted PNG file, which triggers a buffer overflow.</Description>
    <URL>https://github.com/pornel/pngquant/commit/b7c217680cda02dddced245d237ebe8c383be285</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-5766" CVSS="8.8">
    <Description>Integer overflow in the _gd2GetHeader function in gd_gd2.c in the GD Graphics Library (aka libgd) before 2.2.3, as used in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8, allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via crafted chunk dimensions in an image.</Description>
    <URL>http://github.com/php/php-src/commit/7722455726bec8c53458a32851d2a87982cf0eac?w=1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-5767" CVSS="8.8">
    <Description>Integer overflow in the gdImageCreate function in gd.c in the GD Graphics Library (aka libgd) before 2.0.34RC1, as used in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8, allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted image dimensions.</Description>
    <URL>http://github.com/php/php-src/commit/c395c6e5d7e8df37a21265ff76e48fe75ceb5ae6?w=1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-5769" CVSS="9.8">
    <Description>Multiple integer overflows in mcrypt.c in the mcrypt extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allow remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted length value, related to the (1) mcrypt_generic and (2) mdecrypt_generic functions.</Description>
    <URL>http://github.com/php/php-src/commit/6c5211a0cef0cc2854eaa387e0eb036e012904d0?w=1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-5770" CVSS="9.8">
    <Description>Integer overflow in the SplFileObject::fread function in spl_directory.c in the SPL extension in PHP before 5.5.37 and 5.6.x before 5.6.23 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer argument, a related issue to CVE-2016-5096.</Description>
    <URL>http://github.com/php/php-src/commit/7245bff300d3fa8bacbef7897ff080a6f1c23eba?w=1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-5841" CVSS="9.8">
    <Description>Integer overflow in MagickCore/profile.c in ImageMagick before 7.0.2-1 allows remote attackers to cause a denial of service (segmentation fault) or possibly execute arbitrary code via vectors involving the offset variable.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-5844" CVSS="6.5">
    <Description>Integer overflow in the ISO parser in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a crafted ISO file.</Description>
    <URL>https://github.com/libarchive/libarchive/commit/3ad08e01b4d253c66ae56414886089684155af22</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-6250" CVSS="8.6">
    <Description>Integer overflow in the ISO9660 writer in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) or execute arbitrary code via vectors related to verifying filename lengths when writing an ISO9660 archive, which trigger a buffer overflow.</Description>
    <URL>https://github.com/libarchive/libarchive/commit/3014e198</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-6560" CVSS="8.6">
    <Description>illumos osnet-incorporation bcopy() and bzero() implementations make signed instead of unsigned comparisons allowing a system crash.</Description>
    <URL>https://github.com/illumos/illumos-gate/commit/5aaab1a49679c26dbcb6fb6dc25799950d70cc71</URL>
    <CWE CWE="20">
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Type" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Type" />
    </CWE>
    <CWE CWE="195">
      <MainWeakness Cause="Erroneous Code" Operation="Coerce" Consequence="Wrong Value" />
    </CWE>
    <Failure Comment="via System Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-6823" CVSS="7.5">
    <Description>Integer overflow in the BMP coder in ImageMagick before 7.0.2-10 allows remote attackers to cause a denial of service (crash) via crafted height and width values, which triggers an out-of-bounds write.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/4cc6ec8a4197d4c008577127736bf7985d632323</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-6871" CVSS="9.8">
    <Description>Integer overflow in bcmath in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, which triggers a buffer overflow.</Description>
    <URL>https://github.com/facebook/hhvm/commit/c00fc9d3003eb06226b58b6a48555f1456ee2475</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-6872" CVSS="9.8">
    <Description>Integer overflow in StringUtil::implode in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors.</Description>
    <URL>https://github.com/facebook/hhvm/commit/2c9a8fcc73a151608634d3e712973d192027c271</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2016-7133" CVSS="8.1">
    <Description>Zend/zend_alloc.c in PHP 7.x before 7.0.10, when open_basedir is enabled, mishandles huge realloc operations, which allows remote attackers to cause a denial of service (integer overflow) or possibly have unspecified other impact via a long pathname.</Description>
    <URL>https://github.com/php/php-src/commit/c2a13ced4272f2e65d2773e2ea6ca11c1ce4a911?w=1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-7163" CVSS="7.8">
    <Description>Integer overflow in the opj_pi_create_decode function in pi.c in OpenJPEG allows remote attackers to execute arbitrary code via a crafted JP2 file, which triggers an out-of-bounds read or write.</Description>
    <URL>https://github.com/uclouvain/openjpeg/commit/c16bc057ba3f125051c9966cf1f5b68a05681de4</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-7530" CVSS="6.5">
    <Description>The quantum handling code in ImageMagick allows remote attackers to cause a denial of service (divide-by-zero error or out-of-bounds write) via a crafted file.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/63346f34f9d19179599b5b256e5e8d3dda46435c</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-7568" CVSS="9.8">
    <Description>Integer overflow in the gdImageWebpCtx function in gd_webp.c in the GD Graphics Library (aka libgd) through 2.2.3, as used in PHP through 7.0.11, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted imagewebp and imagedestroy calls.</Description>
    <URL>https://github.com/libgd/libgd/commit/40bec0f38f50e8510f5bb71a82f516d46facde03</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-7944" CVSS="9.8">
    <Description>Integer overflow in X.org libXfixes before 5.0.3 on 32-bit platforms might allow remote X servers to gain privileges via a length value of INT_MAX, which triggers the client to stop reading data and get out of sync.</Description>
    <URL>https://cgit.freedesktop.org/xorg/lib/libXfixes/commit/?id=61c1039ee23a2d1de712843bed3480654d7ef42e</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Gain Privilege">Impersonation (IMP)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-7945" CVSS="7.5">
    <Description>Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.</Description>
    <URL>https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Infinite Loop">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-7947" CVSS="9.8">
    <Description>Multiple integer overflows in X.org libXrandr before 1.5.1 allow remote X servers to trigger out-of-bounds write operations via a crafted response.</Description>
    <URL>https://cgit.freedesktop.org/xorg/lib/libXrandr/commit/?id=a0df3e1c7728205e5c7650b2e6dce684139254a6</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure>Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-7951" CVSS="9.8">
    <Description>Multiple integer overflows in X.org libXtst before 1.2.3 allow remote X servers to trigger out-of-bounds memory access operations by leveraging the lack of range checks.</Description>
    <URL>https://cgit.freedesktop.org/xorg/lib/libXtst/commit/?id=9556ad67af3129ec4a7a4f4b54a0d59701beeae3</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2016-8636" CVSS="7.8">
    <Description>Integer overflow in the mem_check_range function in drivers/infiniband/sw/rxe/rxe_mr.c in the Linux kernel before 4.9.10 allows local users to cause a denial of service (memory corruption), obtain sensitive information from kernel memory, or possibly have unspecified other impact via a write or read request involving the "RDMA protocol over infiniband" (aka Soft RoCE) technology.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=647bf3d8a8e5777319da92af672289b2a6c4dc66</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-8691" CVSS="5.5">
    <Description>The jpc_dec_process_siz function in libjasper/jpc/jpc_dec.c in JasPer before 1.900.4 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted XRsiz value in a BMP image to the imginfo command.</Description>
    <URL>https://github.com/mdadams/jasper/commit/d8c2604cd438c41ec72aff52c16ebd8183068020</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-8692" CVSS="5.5">
    <Description>The jpc_dec_process_siz function in libjasper/jpc/jpc_dec.c in JasPer before 1.900.4 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted YRsiz value in a BMP image to the imginfo command.</Description>
    <URL>https://github.com/mdadams/jasper/commit/d8c2604cd438c41ec72aff52c16ebd8183068020</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-9083" CVSS="7.8">
    <Description>drivers/vfio/pci/vfio_pci.c in the Linux kernel through 4.8.11 allows local users to bypass integer overflow checks, and cause a denial of service (memory corruption) or have unspecified other impact, by leveraging access to a vfio PCI device file for a VFIO_DEVICE_SET_IRQS ioctl call, aka a "state machine confusion bug."</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=05692d7005a364add85c6e25a6c4447ce08f913a</URL>
    <CWE CWE="119">
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-9084" CVSS="7.8">
    <Description>drivers/vfio/pci/vfio_pci_intrs.c in the Linux kernel through 4.8.11 misuses the kzalloc function, which allows local users to cause a denial of service (integer overflow) or have unspecified other impact by leveraging access to a vfio PCI device file.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=05692d7005a364add85c6e25a6c4447ce08f913a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-9123" CVSS="7.5">
    <Description>go-jose before 1.0.5 suffers from a CBC-HMAC integer overflow on 32-bit architectures. An integer overflow could lead to authentication bypass for CBC-HMAC encrypted ciphertexts on 32-bit architectures.</Description>
    <URL>https://github.com/square/go-jose/commit/789a4c4bd4c118f7564954f441b29c153ccd6a96</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2016-9132" CVSS="9.8">
    <Description>In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure.</Description>
    <URL>https://github.com/randombit/botan/commit/987ad747db6d0d7e36f840398f3cf02e2fbfd90f</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-9262" CVSS="5.5">
    <Description>Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.</Description>
    <URL>https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-9387" CVSS="7.8">
    <Description>Integer overflow in the jpc_dec_process_siz function in libjasper/jpc/jpc_dec.c in JasPer before 1.900.13 allows remote attackers to have unspecified impact via a crafted file, which triggers an assertion failure.</Description>
    <URL>https://github.com/mdadams/jasper/commit/d91198abd00fc435a397fe6bad906a4c1748e9cf</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2016-9445" CVSS="7.5">
    <Description>Integer overflow in the vmnc decoder in the gstreamer allows remote attackers to cause a denial of service (crash) via large width and height values, which triggers a buffer overflow.</Description>
    <URL>https://cgit.freedesktop.org/gstreamer/gst-plugins-bad/commit/gst/vmnc/vmncdec.c?id=4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-9538" CVSS="9.8">
    <Description>tools/tiffcrop.c in libtiff 4.0.6 reads an undefined buffer in readContigStripsIntoBuffer() because of a uint16 integer overflow. Reported as MSVR 35100.</Description>
    <URL>https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b#diff-c8b4b355f9b5c06d585b23138e1c185f</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2016-9557" CVSS="5.5">
    <Description>Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.</Description>
    <URL>https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-9580" CVSS="8.8">
    <Description>An integer overflow vulnerability was found in tiftoimage function in openjpeg 2.1.2, resulting in heap buffer overflow.</Description>
    <URL>https://github.com/szukw000/openjpeg/commit/cadff5fb6e73398de26a92e96d3d7cac893af255</URL>
    <CWE CWE="122">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2016-9583" CVSS="7.8">
    <Description>An out-of-bounds heap read vulnerability was found in the jpc_pi_nextpcrl() function of jasper before 2.0.6 when processing crafted input.</Description>
    <URL>https://github.com/mdadams/jasper/commit/aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2016-9754" CVSS="7.8">
    <Description>The ring_buffer_resize function in kernel/trace/ring_buffer.c in the profiling subsystem in the Linux kernel before 4.6.1 mishandles certain integer calculations, which allows local users to gain privileges by writing to the /sys/kernel/debug/tracing/buffer_size_kb file.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=59643d1535eb220668692a5359de22545af579f6</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Gain Privilege">Impersonation (IMP)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-0521" CVSS="7.0">
    <Description>An elevation of privilege vulnerability in the Qualcomm camera driver could enable a local malicious application to execute arbitrary code within the context of the kernel. This issue is rated as High because it first requires compromising a privileged process. Product: Android. Versions: Kernel-3.10, Kernel-3.18. Android ID: A-32919951. References: QC-CR#1097709.</Description>
    <URL>https://source.codeaurora.org/quic/la/kernel/msm-3.18/commit/?id=dbe4f26f200db10deaf38676b96d8738afcc10c8</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-0553" CVSS="7.0">
    <Description>An elevation of privilege vulnerability in libnl could enable a local malicious application to execute arbitrary code within the context of the Wi-Fi service. This issue is rated as Moderate because it first requires compromising a privileged process and is mitigated by current platform configurations. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-32342065. NOTE: this issue also exists in the upstream libnl before 3.3.0 library.</Description>
    <URL>http://git.infradead.org/users/tgr/libnl.git/commit/3e18948f17148e6a3c4255bdeaaf01ef6081ceeb</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-0576" CVSS="7.0">
    <Description>An elevation of privilege vulnerability in the Qualcomm crypto engine driver could enable a local malicious application to execute arbitrary code within the context of the kernel. This issue is rated as High because it first requires compromising a privileged process. Product: Android. Versions: Kernel-3.10, Kernel-3.18. Android ID: A-33544431. References: QC-CR#1103089.</Description>
    <URL>https://github.com/derrekr/android_security/commit/0dd1a733e60cf5239c0a185d4219ba2ef1118a8b</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-1000414" CVSS="7.5">
    <Description>ImpulseAdventure JPEGsnoop version 1.7.5 is vulnerable to a division by zero in the JFIF decode handling resulting denial of service.</Description>
    <URL>https://github.com/ImpulseAdventure/JPEGsnoop/commit/b4e458612d4294e0cfe01dbf1c0b09a07a8133a4#diff-cf9182aecc9d630e8db2e0e35f1eec65</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-1000470" CVSS="7.5">
    <Description>EmbedThis GoAhead Webserver versions 4.0.0 and earlier is vulnerable to an integer overflow in the HTTP listener resulting in denial of service.</Description>
    <URL>https://github.com/embedthis/goahead/commit/adeb4abc6c998c19524e09fde20c02b4a26765a3</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-11464" CVSS="7.8">
    <Description>A SIGFPE is raised in the function box_blur_line of rsvg-filter.c in GNOME librsvg 2.40.17 during an attempted parse of a crafted SVG file, because of incorrect protection against division by zero.</Description>
    <URL>https://git.gnome.org/browse/librsvg/commit/?id=ecf9267a24b2c3c0cd211dbdfa9ef2232511972a</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-12177" CVSS="9.8">
    <Description>xorg-x11-server before 1.19.5 was vulnerable to integer overflow in ProcDbeGetVisualInfo function allowing malicious X client to cause X server to crash or possibly execute arbitrary code.</Description>
    <URL>https://cgit.freedesktop.org/xorg/xserver/commit/?id=4ca68b878e851e2136c234f40a25008297d8d831</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-12179" CVSS="9.8">
    <Description>xorg-x11-server before 1.19.5 was vulnerable to integer overflow in (S)ProcXIBarrierReleasePointer functions allowing malicious X client to cause X server to crash or possibly execute arbitrary code.</Description>
    <URL>https://cgit.freedesktop.org/xorg/xserver/commit/?id=d088e3c1286b548a58e62afdc70bb40981cdb9e8</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-14061" CVSS="9.8">
    <Description>Integer overflow in the _isBidi function in bidi.c in Libidn2 before 2.0.4 allows remote attackers to cause a denial of service or possibly have unspecified other impact.</Description>
    <URL>https://gitlab.com/libidn/libidn2/commit/16853b6973a1e72fee2b7cccda85472cb9951305</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-14062" CVSS="9.8">
    <Description>Integer overflow in the decode_digit function in puny_decode.c in Libidn2 before 2.0.4 allows remote attackers to cause a denial of service or possibly have unspecified other impact.</Description>
    <URL>https://gitlab.com/libidn/libidn2/commit/3284eb342cd0ed1a18786e3fcdf0cdd7e76676bd</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-14106" CVSS="5.5">
    <Description>The tcp_disconnect function in net/ipv4/tcp.c in the Linux kernel before 4.12 allows local users to cause a denial of service (__tcp_select_window divide-by-zero error and system crash) by triggering a disconnect within a certain tcp_recvmsg code path.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=499350a5a6e7512d9ed369ed63a4244b6536f4f8</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via System Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-14173" CVSS="6.5">
    <Description>In the function ReadTXTImage() in coders/txt.c in ImageMagick 7.0.6-10, an integer overflow might occur for the addition operation "GetQuantumRange(depth)+1" when "depth" is large, producing a smaller value than expected. As a result, an infinite loop would occur for a crafted TXT file that claims a very large "max_value" value.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/50f54462076648ac2e36c3f58f4dadd4babbf1c9</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Infinite Loop">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-14502" CVSS="7.5">
    <Description>read_header in archive_read_support_format_rar.c in libarchive 3.3.2 suffers from an off-by-one error for UTF-16 names in RAR archives, leading to an out-of-bounds read in archive_read_format_rar_read_header.</Description>
    <URL>https://github.com/libarchive/libarchive/commit/5562545b5562f6d12a4ef991fae158bf4ccf92b6</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-14887" CVSS="7.8">
    <Description>In Android for MSM, Firefox OS for MSM, QRD Android, with all Android releases from CAF using the Linux kernel, in the processing of messages of type eWNI_SME_MODIFY_ADDITIONAL_IES, an integer overflow leading to heap buffer overflow may potentially occur.</Description>
    <URL>https://source.codeaurora.org/quic/la/platform/vendor/qcom-opensource/wlan/qcacld-3.0/commit/?id=4ce28e7c85f89e2c3555ec840b6adda47bd5dab0</URL>
    <CWE CWE="119">
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-15818" CVSS="7.8">
    <Description>In all android releases (Android for MSM, Firefox OS for MSM, QRD Android) from CAF using the linux kernel, while loading a user application in qseecom, an integer overflow could potentially occur if the application partition size is rounded up to page_size.</Description>
    <URL>https://source.codeaurora.org/quic/la/kernel/lk/commit/?id=abe4f7042cbdef928ffc152335a17150fb39b096</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2017-15828" CVSS="7.8">
    <Description>In all android releases (Android for MSM, Firefox OS for MSM, QRD Android) from CAF using the linux kernel, while accessing the keystore in LK, an integer overflow vulnerability exists which may potentially lead to a buffer overflow.</Description>
    <URL>https://source.codeaurora.org/quic/la/kernel/lk/commit/?id=86ea9e5dd16d918f8960067157012cc15176f82f</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-15831" CVSS="7.8">
    <Description>In Android for MSM, Firefox OS for MSM, QRD Android, with all Android releases from CAF using the Linux kernel, in the function wma_ndp_end_indication_event_handler(), there is no input validation check on a event_info value coming from firmware, which can cause an integer overflow and then leads to potential heap overwrite.</Description>
    <URL>https://source.codeaurora.org/quic/la/platform/vendor/qcom-opensource/wlan/qcacld-3.0/commit/?id=31e6a657320e4299c659e3d57d38a89afe8c1ce1</URL>
    <CWE CWE="20">
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Type" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Type" />
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2017-15873" CVSS="5.5">
    <Description>The get_next_block function in archival/libarchive/decompress_bunzip2.c in BusyBox 1.27.2 has an Integer Overflow that may lead to a write access violation.</Description>
    <URL>https://git.busybox.net/busybox/commit/?id=0402cb32df015d9372578e3db27db47b33d5c7b0</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2017-16612" CVSS="7.5">
    <Description>libXcursor before 1.1.15 has various integer overflows that could lead to heap buffer overflows when processing malicious cursors, e.g., with programs like GIMP. It is also possible that an attack vector exists against the related code in cursor/xcursor.c in Wayland through 1.14.0.</Description>
    <URL>https://cgit.freedesktop.org/wayland/wayland/commit/?id=5d201df72f3d4f4cb8b8f75f980169b03507da38</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-17766" CVSS="9.8">
    <Description>In wma_peer_info_event_handler() in Android for MSM, Firefox OS for MSM, and QRD Android before 2017-10-03, the value of num_peers received from firmware is not properly validated so that an integer overflow vulnerability in the size of a buffer allocation may potentially lead to a buffer overflow.</Description>
    <URL>https://source.codeaurora.org/quic/la/platform/vendor/qcom-opensource/wlan/qcacld-3.0/commit/?id=a37d8a78f5bd0e9a2c91de46721a6d80bd229a43</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-17854" CVSS="7.8">
    <Description>kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (integer overflow and memory corruption) or possibly have unspecified other impact by leveraging unrestricted integer values for pointer arithmetic.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=bb7f0f989ca7de1153bd128a40a71709e339fa03</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-18187" CVSS="9.8">
    <Description>In ARM mbed TLS before 2.7.0, there is a bounds-check bypass through an integer overflow in PSK identity parsing in the ssl_parse_client_psk_identity() function in library/ssl_srv.c.</Description>
    <URL>https://github.com/ARMmbed/mbedtls/commit/83c9f495ffe70c7dd280b41fdfd4881485a3bc28</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2017-18233" CVSS="5.5">
    <Description>An issue was discovered in Exempi before 2.4.4. Integer overflow in the Chunk class in XMPFiles/source/FormatSupport/RIFF.cpp allows remote attackers to cause a denial of service (infinite loop) via crafted XMP data in a .avi file.</Description>
    <URL>https://cgit.freedesktop.org/exempi/commit/?id=65a8492832b7335ffabd01f5f64d89dec757c260</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Infinite Loop">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-18255" CVSS="7.8">
    <Description>The perf_cpu_time_max_percent_handler function in kernel/events/core.c in the Linux kernel before 4.11 allows local users to cause a denial of service (integer overflow) or possibly have unspecified other impact via a large value, as demonstrated by an incorrect sample-rate calculation.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=1572e45a924f254d9570093abde46430c3172e3d</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-18257" CVSS="5.5">
    <Description>The __get_data_block function in fs/f2fs/data.c in the Linux kernel before 4.11 allows local users to cause a denial of service (integer overflow and loop) via crafted use of the open and fallocate system calls with an FS_IOC_FIEMAP ioctl.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=b86e33075ed1909d8002745b56ecf73b833db143</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-18360" CVSS="5.5">
    <Description>In change_port_settings in drivers/usb/serial/io_ti.c in the Linux kernel before 4.11.3, local users could cause a denial of service by division-by-zero in the serial device layer by trying to set very high baud rates.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6aeb75e6adfaed16e58780309613a578fe1ee90b</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-20005" CVSS="9.8">
    <Description>NGINX before 1.13.6 has a buffer overflow for years that exceed four digits, as demonstrated by a file with a modification date in 1969 that causes an integer overflow (or a false modification date far in the future), when encountered by the autoindex module.</Description>
    <URL>https://github.com/nginx/nginx/commit/0206ebe76f748bb39d9de4dd4b3fce777fdfdccf</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-2618" CVSS="5.5">
    <Description>A flaw was found in the Linux kernel's handling of clearing SELinux attributes on /proc/pid/attr files before 4.9.10. An empty (null) write to this file can crash the system by causing the system to attempt to access unmapped kernel memory.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0c461cb727d146c9ef2d3e86214f498b78b7d125</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure>Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-5333" CVSS="7.8">
    <Description>Integer overflow in the extract_group_icon_cursor_resource function in b/wrestool/extract.c in icoutils before 0.31.1 allows local users to cause a denial of service (process crash) or execute arbitrary code via a crafted executable file.</Description>
    <URL>https://git.savannah.gnu.org/cgit/icoutils.git/commit/?id=1a108713ac26215c7568353f6e02e727e6d4b24a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-5340" CVSS="9.8">
    <Description>Zend/zend_hash.c in PHP before 7.0.15 and 7.1.x before 7.1.1 mishandles certain cases that require large array allocations, which allows remote attackers to execute arbitrary code or cause a denial of service (integer overflow, uninitialized memory access, and use of arbitrary destructor function pointers) via crafted serialized data.</Description>
    <URL>https://github.com/php/php-src/commit/4cc0286f2f3780abc6084bcdae5dce595daa3c12</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-5576" CVSS="7.8">
    <Description>Integer overflow in the vc4_get_bcl function in drivers/gpu/drm/vc4/vc4_gem.c in the VideoCore DRM driver in the Linux kernel before 4.9.7 allows local users to cause a denial of service or possibly have unspecified other impact via a crafted size value in a VC4_SUBMIT_CL ioctl call.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=0f2ff82e11c86c05d051cae32b58226392d33bbf</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-5885" CVSS="9.8">
    <Description>Multiple integer overflows in the (1) vnc_connection_server_message and (2) vnc_color_map_set functions in gtk-vnc before 0.7.0 allow remote servers to cause a denial of service (crash) or possibly execute arbitrary code via vectors involving SetColorMapEntries, which triggers a buffer overflow.</Description>
    <URL>https://git.gnome.org/browse/gtk-vnc/commit/?id=c8583fd3783c5b811590fcb7bae4ce6e7344963e</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-5953" CVSS="9.8">
    <Description>vim before patch 8.0.0322 does not properly validate values for tree length when handling a spell file, which may result in an integer overflow at a memory allocation site and a resultant buffer overflow.</Description>
    <URL>https://github.com/vim/vim/commit/399c297aa93afe2c0a39e2a1b3f972aebba44c9d</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-6308" CVSS="7.8">
    <Description>An issue was discovered in tnef before 1.4.13. Several Integer Overflows, which can lead to Heap Overflows, have been identified in the functions that wrap memory allocation.</Description>
    <URL>https://github.com/verdammelt/tnef/commit/c5044689e50039635e7700fe2472fd632ac77176</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2017-6349" CVSS="9.8">
    <Description>An integer overflow at a u_read_undo memory allocation site would occur for vim before patch 8.0.0377, if it does not properly validate values for tree length when reading a corrupted undo file, which may lead to resultant buffer overflows.</Description>
    <URL>https://github.com/vim/vim/commit/3eb1637b1bba19519885dd6d377bd5596e91d22c</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-6350" CVSS="9.8">
    <Description>An integer overflow at an unserialize_uep memory allocation site would occur for vim before patch 8.0.0378, if it does not properly validate values for tree length when reading a corrupted undo file, which may lead to resultant buffer overflows.</Description>
    <URL>https://github.com/vim/vim/commit/0c8485f0e4931463c0f7986e1ea84a7d79f10c75</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-6355" CVSS="5.5">
    <Description>Integer overflow in the vrend_create_shader function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (process crash) via crafted pkt_length and offlen values, which trigger an out-of-bounds access.</Description>
    <URL>https://cgit.freedesktop.org/virglrenderer/commit/?id=93761787b29f37fa627dea9082cdfc1a1ec608d6</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-6838" CVSS="5.5">
    <Description>Integer overflow in sfcommands/sfconvert.c in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file.</Description>
    <URL>https://github.com/antlarr/audiofile/commit/7d65f89defb092b63bcbc5d98349fb222ca73b3c</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-6839" CVSS="5.5">
    <Description>Integer overflow in modules/MSADPCM.cpp in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file.</Description>
    <URL>https://github.com/antlarr/audiofile/commit/beacc44eb8cdf6d58717ec1a5103c5141f1b37f9</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-6889" CVSS="9.8">
    <Description>An integer overflow error within the "foveon_load_camf()" function (dcraw_foveon.c) in LibRaw-demosaic-pack-GPL2 before 0.18.2 can be exploited to cause a heap-based buffer overflow.</Description>
    <URL>https://github.com/LibRaw/LibRaw-demosaic-pack-GPL2/commit/194f592e205990ea8fce72b6c571c14350aca716</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-6952" CVSS="8.8">
    <Description>Integer overflow in the cs_winkernel_malloc function in winkernel_mm.c in Capstone 3.0.4 and earlier allows attackers to cause a denial of service (heap-based buffer overflow in a kernel driver) or possibly have unspecified other impact via a large value.</Description>
    <URL>https://github.com/aquynh/capstone/commit/6fe86eef621b9849f51a5e1e5d73258a93440403</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-7448" CVSS="5.5">
    <Description>The allocate_channel_framebuffer function in uncompressed_components.hh in Dropbox Lepton 1.2.1 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a malformed JPEG image.</Description>
    <URL>https://github.com/dropbox/lepton/commit/7789d99ac156adfd7bbf66e7824bd3e948a74cf7</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-7482" CVSS="7.8">
    <Description>In the Linux kernel before version 4.12, Kerberos 5 tickets decoded when using the RXRPC keys incorrectly assumes the size of a field. This could lead to the size-remaining variable wrapping and the data pointer going over the end of the buffer. This could possibly lead to memory corruption and possible privilege escalation.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5f2f97656ada8d811d3c1bef503ced266fcd53a0</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-7542" CVSS="5.5">
    <Description>The ip6_find_1stfragopt function in net/ipv6/output_core.c in the Linux kernel through 4.12.3 allows local users to cause a denial of service (integer overflow and infinite loop) by leveraging the ability to open a raw socket.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6399f1fae4ec29fab5ec76070435555e256ca3a6</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Infinite Loop">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-7962" CVSS="5.5">
    <Description>The iwgif_read_image function in imagew-gif.c in libimageworsener.a in ImageWorsener 1.3.0 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted file.</Description>
    <URL>https://github.com/jsummers/imageworsener/commit/ca3356eb49fee03e2eaf6b6aff826988c1122d93</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-8326" CVSS="8.8">
    <Description>libimageworsener.a in ImageWorsener before 1.3.1 has "left shift cannot be represented in type int" undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c.</Description>
    <URL>https://github.com/jsummers/imageworsener/commit/a00183107d4b84bc8a714290e824ca9c68dac738</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-8924" CVSS="4.6">
    <Description>The edge_bulk_in_callback function in drivers/usb/serial/io_ti.c in the Linux kernel before 4.10.4 allows local users to obtain sensitive information (in the dmesg ringbuffer and syslog) from uninitialized kernel memory by using a crafted USB device (posing as an io_ti USB serial device) to trigger an integer underflow.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=654b404f2a222f918af9b0cd18ad469d0c941a8e</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2017-8932" CVSS="5.9">
    <Description>A bug in the standard library ScalarMult implementation of curve P-256 for amd64 architectures in Go before 1.7.6 and 1.8.x before 1.8.2 causes incorrect results to be generated for specific input points. An adaptive attack can be mounted to progressively extract the scalar input to ScalarMult by submitting crafted points and observing failures to the derive correct output. This leads to a full key recovery attack against static ECDH, as used in popular JWT libraries.</Description>
    <URL>https://github.com/golang/go/commit/9294fa2749ffee7edbbb817a0ef9fe633136fa9c</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2017-9201" CVSS="6.5">
    <Description>imagew-cmd.c:850:46 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (divide-by-zero error) via a crafted image, related to imagew-api.c.</Description>
    <URL>https://github.com/jsummers/imageworsener/commit/dc49c807926b96e503bd7c0dec35119eecd6c6fe</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2017-9202" CVSS="6.5">
    <Description>imagew-cmd.c:854:45 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (divide-by-zero error) via a crafted image, related to imagew-api.c.</Description>
    <URL>https://github.com/jsummers/imageworsener/commit/dc49c807926b96e503bd7c0dec35119eecd6c6fe</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-1000127" CVSS="7.5">
    <Description>memcached version prior to 1.4.37 contains an Integer Overflow vulnerability in items.c:item_free() that can result in data corruption and deadlocks due to items existing in hash table being reused from free list. This attack appear to be exploitable via network connectivity to the memcached service. This vulnerability appears to have been fixed in 1.4.37 and later.</Description>
    <URL>https://github.com/memcached/memcached/commit/a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-1000524" CVSS="5.5">
    <Description>miniSphere version 5.2.9 and earlier contains a Integer Overflow vulnerability in layer_resize() function in map_engine.c that can result in remote denial of service. This attack appear to be exploitable via the victim must load a specially-crafted map which calls SetLayerSize in its entry script. This vulnerability appears to have been fixed in 5.0.3, 5.1.5, 5.2.10 and later.</Description>
    <URL>https://github.com/fatcerberus/minisphere/commit/252c1ca184cb38e1acb917aa0e451c5f08519996</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-10191" CVSS="9.8">
    <Description>In versions of mruby up to and including 1.4.0, an integer overflow exists in src/vm.c::mrb_vm_exec() when handling OP_GETUPVAR in the presence of deep scope nesting, resulting in a use-after-free. An attacker that can cause Ruby code to be run can use this to possibly execute arbitrary code.</Description>
    <URL>https://github.com/mruby/mruby/commit/1905091634a6a2925c911484434448e568330626</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-10887" CVSS="8.1">
    <Description>A flaw was found in libgit2 before version 0.27.3. It has been discovered that an unexpected sign extension in git_delta_apply function in delta.c file may lead to an integer overflow which in turn leads to an out of bound read, allowing to read before the base object. An attacker may use this flaw to leak memory addresses or cause a Denial of Service.</Description>
    <URL>https://github.com/libgit2/libgit2/commit/3f461902dc1072acb8b7607ee65d0a0458ffac2a</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="194">
      <MainWeakness Cause="Erroneous Code" Operation="Coerce" Consequence="Wrong Value" />
    </CWE>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-11219" CVSS="9.8">
    <Description>An Integer Overflow issue was discovered in the struct library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2, leading to a failure of bounds checking.</Description>
    <URL>https://github.com/antirez/redis/commit/1eb08bcd4634ae42ec45e8284923ac048beaa4c3</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-11260" CVSS="7.8">
    <Description>In all android releases(Android for MSM, Firefox OS for MSM, QRD Android) from CAF using the linux kernel, while processing a fast Initial link setup (FILS) connection request, integer overflow may lead to a buffer overflow when the key length is zero.</Description>
    <URL>https://source.codeaurora.org/quic/la/platform/vendor/qcom-opensource/wlan/qcacld-3.0/commit/?id=9fd239116d9cb19a18b3892b8a1f428636ca1453</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-11262" CVSS="7.8">
    <Description>In Android for MSM, Firefox OS for MSM, and QRD Android with all Android releases from CAF using the Linux kernel while trying to find out total number of partition via a non zero check, there could be possibility where the 'TotalPart' could cross 'GptHeader-&gt;MaxPtCnt' and which could result in OOB write in patching GPT.</Description>
    <URL>https://source.codeaurora.org/quic/la/abl/tianocore/edk2/commit/?id=29ab5eb75bc9ed01466ab1a98e932e59fe27ad42</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-11301" CVSS="7.8">
    <Description>In all android releases (Android for MSM, Firefox OS for MSM, QRD Android) from CAF using the linux kernel, lack of check on buffer length while processing debug log event from firmware can lead to an integer overflow.</Description>
    <URL>https://source.codeaurora.org/quic/la/platform/vendor/qcom-opensource/wlan/qcacld-2.0/commit/?id=31ad3a5a7458e60f5e0ba4f492cebe1f1bda0964</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-1152" CVSS="6.5">
    <Description>libjpeg-turbo 1.5.90 is vulnerable to a denial of service vulnerability caused by a divide by zero when processing a crafted BMP image.</Description>
    <URL>https://github.com/libjpeg-turbo/libjpeg-turbo/commit/43e84cff1bb2bd8293066f6ac4eb0df61ddddbc6</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-11590" CVSS="5.5">
    <Description>Espruino before 1.99 allows attackers to cause a denial of service (application crash) with a user crafted input file via an integer overflow during syntax parsing. This was addressed by fixing stack size detection on Linux in jsutils.c.</Description>
    <URL>https://github.com/espruino/Espruino/commit/a0d7f432abee692402c00e8b615ff5982dde9780</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-11826" CVSS="7.8">
    <Description>In all android releases (Android for MSM, Firefox OS for MSM, QRD Android) from CAF using the linux kernel, lack of check on integer overflow while calculating memory can lead to Buffer overflow in WLAN ext scan handler.</Description>
    <URL>https://source.codeaurora.org/quic/la/platform/vendor/qcom-opensource/wlan/qcacld-3.0/commit/?id=650afe0c0ec2f566c9546b3b8e400b36fcf44aed</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-11886" CVSS="7.8">
    <Description>In all android releases (Android for MSM, Firefox OS for MSM, QRD Android) from CAF using the linux kernel, lack of check while calculating the MPDU data length will cause an integer overflow and then to buffer overflow in WLAN function.</Description>
    <URL>https://source.codeaurora.org/quic/la/platform/vendor/qcom-opensource/wlan/qcacld-3.0/commit/?id=cc0e6489d67d3fc7b196cf6806a7a5edcff33a88</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-11894" CVSS="7.8">
    <Description>In all android releases (Android for MSM, Firefox OS for MSM, QRD Android) from CAF using the linux kernel, while processing preferred network offload scan results integer overflow may lead to buffer overflow when large frame length is received from FW.</Description>
    <URL>https://source.codeaurora.org/quic/la/platform/vendor/qcom-opensource/wlan/qcacld-3.0/commit/?id=e60c5608f843ec106a98a98b33de0c3be070d557</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-12896" CVSS="5.5">
    <Description>An issue was discovered in the Linux kernel through 4.17.3. An Integer Overflow in kernel/time/posix-timers.c in the POSIX timer code is caused by the way the overrun accounting works. Depending on interval and expiry time values, the overrun can be larger than INT_MAX, but the accounting is int based. This basically makes the accounting values, which are visible to user space via timer_getoverrun(2) and siginfo::si_overrun, random. For example, a local user can cause a denial of service (signed integer overflow) via crafted mmap, futex, timer_create, and timer_settime system calls.</Description>
    <URL>https://github.com/torvalds/linux/commit/78c9c4dfbf8c04883941445a195276bb4bb92c76</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-13053" CVSS="3.3">
    <Description>The alarm_timer_nsleep function in kernel/time/alarmtimer.c in the Linux kernel through 4.17.3 has an integer overflow via a large relative timeout because ktime_add_safe is not used.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=5f936e19cc0ef97dbe3a56e9498922ad5ba1edef</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-13097" CVSS="5.5">
    <Description>An issue was discovered in fs/f2fs/super.c in the Linux kernel through 4.17.3. There is an out-of-bounds read or a divide-by-zero error for an incorrect user_block_count in a corrupted f2fs image, leading to a denial of service (BUG).</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9dc956b2c8523aed39d1e6508438be9fea28c8fc</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-13100" CVSS="5.5">
    <Description>An issue was discovered in fs/f2fs/super.c in the Linux kernel through 4.17.3, which does not properly validate secs_per_zone in a corrupted f2fs image, as demonstrated by a divide-by-zero error.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=42bf546c1fe3f3654bdf914e977acbc2b80a5be5</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-13406" CVSS="7.8">
    <Description>An integer overflow in the uvesafb_setcmap function in drivers/video/fbdev/uvesafb.c in the Linux kernel before 4.17.4 could result in local attackers being able to crash the kernel or potentially elevate privileges because kmalloc_array is not used.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=9f645bcc566a1e9f921bdae7528a01ced5bc3713</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-13785" CVSS="6.5">
    <Description>In libpng 1.6.34, a wrong calculation of row_factor in the png_check_chunk_length function (pngrutil.c) may trigger an integer overflow and resultant divide-by-zero while processing a crafted PNG file, leading to a denial of service.</Description>
    <URL>https://github.com/glennrp/libpng/commit/8a05766cb74af05c04c53e6c9d60c13fc4d59bf2</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-14353" CVSS="9.8">
    <Description>An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap_quote_string in imap/util.c has an integer underflow.</Description>
    <URL>https://github.com/neomutt/neomutt/commit/65d64a5b60a4a3883f2cd799d92c6091d8854f23</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-14394" CVSS="6.5">
    <Description>libavformat/movenc.c in FFmpeg before 4.0.2 allows attackers to cause a denial of service (application crash caused by a divide-by-zero error) with a user crafted Waveform audio file.</Description>
    <URL>https://github.com/FFmpeg/FFmpeg/commit/3a2d21bc5f97aa0161db3ae731fc2732be6108b8</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-14395" CVSS="6.5">
    <Description>libavformat/movenc.c in FFmpeg 3.2 and 4.0.2 allows attackers to cause a denial of service (application crash caused by a divide-by-zero error) with a user crafted audio file when converting to the MOV audio format.</Description>
    <URL>https://github.com/FFmpeg/FFmpeg/commit/2c0e98a0b478284bdff6d7a4062522605a8beae5</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-14599" CVSS="9.8">
    <Description>An issue was discovered in libX11 through 1.6.5. The function XListExtensions in ListExt.c is vulnerable to an off-by-one error caused by malicious server responses, leading to DoS or possibly unspecified other impact.</Description>
    <URL>https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=b469da1430cdcee06e31c6251b83aede072a1ff0</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-14679" CVSS="6.5">
    <Description>An issue was discovered in mspack/chmd.c in libmspack before 0.7alpha. There is an off-by-one error in the CHM PMGI/PMGL chunk number validity checks, which could lead to denial of service (uninitialized data dereference and application crash).</Description>
    <URL>https://github.com/kyz/libmspack/commit/72e70a921f0f07fee748aec2274b30784e1d312a</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One, via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-14682" CVSS="8.8">
    <Description>An issue was discovered in mspack/chmd.c in libmspack before 0.7alpha. There is an off-by-one error in the TOLOWER() macro for CHM decompression.</Description>
    <URL>https://github.com/kyz/libmspack/commit/4fd9ccaa54e1aebde1e4b95fb0163b699fd7bcc8</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-14938" CVSS="9.1">
    <Description>An issue was discovered in wifipcap/wifipcap.cpp in TCPFLOW through 1.5.0-alpha. There is an integer overflow in the function handle_prism during caplen processing. If the caplen is less than 144, one can cause an integer overflow in the function handle_80211, which will result in an out-of-bounds read and may allow access to sensitive memory (or a denial of service).</Description>
    <URL>https://github.com/simsong/tcpflow/commit/a4e1cd14eb5ccc51ed271b65b3420f7d692c40eb</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-16301" CVSS="7.8">
    <Description>The command-line argument parser in tcpdump before 4.99.0 has a buffer overflow in tcpdump.c:read_infile(). To trigger this vulnerability the attacker needs to create a 4GB file on the local filesystem and to specify the file name as the value of the -F command-line argument of tcpdump.</Description>
    <URL>https://github.com/the-tcpdump-group/tcpdump/commit/ad7c25bc0decf96dc7768c9e903734d38528b1bd</URL>
    <CWE CWE="120">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-16435" CVSS="5.5">
    <Description>Little CMS (aka Little Color Management System) 2.9 has an integer overflow in the AllocateDataSet function in cmscgats.c, leading to a heap-based buffer overflow in the SetData function via a crafted file in the second argument to cmsIT8LoadFromFile.</Description>
    <URL>https://github.com/mm2/Little-CMS/commit/768f70ca405cd3159d990e962d54456773bb8cf8</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-16839" CVSS="9.8">
    <Description>Curl versions 7.33.0 through 7.61.1 are vulnerable to a buffer overrun in the SASL authentication code that may lead to denial of service.</Description>
    <URL>https://github.com/curl/curl/commit/f3a24d7916b9173c69a3e0ee790102993833d6c5</URL>
    <CWE CWE="119">
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="122">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-17568" CVSS="9.8">
    <Description>utils/ut_rpc.c in ViaBTC Exchange Server before 2018-08-21 has an integer overflow leading to memory corruption.</Description>
    <URL>https://github.com/viabtc/viabtc_exchange_server/commit/4a7c27bfe98f409623d4d857894d017ff0672cc9#diff-0c23effa84a7b85053bac7981a8580c8</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-17569" CVSS="9.8">
    <Description>network/nw_buf.c in ViaBTC Exchange Server before 2018-08-21 has an integer overflow leading to memory corruption.</Description>
    <URL>https://github.com/viabtc/viabtc_exchange_server/commit/4a7c27bfe98f409623d4d857894d017ff0672cc9#diff-9fabc53ea796ec492aef432594298baa</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-17570" CVSS="9.8">
    <Description>utils/ut_ws_svr.c in ViaBTC Exchange Server before 2018-08-21 has an integer overflow leading to memory corruption.</Description>
    <URL>https://github.com/viabtc/viabtc_exchange_server/commit/4a7c27bfe98f409623d4d857894d017ff0672cc9#diff-515c81af848352583bff286d6224875f</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-18206" CVSS="7.5">
    <Description>In the client in Bytom before 1.0.6, checkTopicRegister in p2p/discover/net.go does not prevent negative idx values, leading to a crash.</Description>
    <URL>https://github.com/Bytom/bytom/commit/1ac3c8ac4f2b1e1df9675228290bda6b9586ba42</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-18311" CVSS="9.8">
    <Description>Perl before 5.26.3 and 5.28.x before 5.28.1 has a buffer overflow via a crafted regular expression that triggers invalid write operations.</Description>
    <URL>https://github.com/Perl/perl5/commit/34716e2a6ee2af96078d62b065b7785c001194be</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-18928" CVSS="9.8">
    <Description>International Components for Unicode (ICU) for C/C++ 63.1 has an integer overflow in number::impl::DecimalQuantity::toScientificString() in i18n/number_decimalquantity.cpp.</Description>
    <URL>https://github.com/unicode-org/icu/commit/53d8c8f3d181d87a6aa925b449b51c4a2c922a51</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-19199" CVSS="9.8">
    <Description>An issue was discovered in uriparser before 0.9.0. UriQuery.c allows an integer overflow via a uriComposeQuery* or uriComposeQueryEx* function because of an unchecked multiplication.</Description>
    <URL>https://github.com/uriparser/uriparser/commit/f76275d4a91b28d687250525d3a0c5509bbd666f</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-20177" CVSS="9.8">
    <Description>rdesktop versions up to and including v1.8.3 contain an Integer Overflow that leads to a Heap-Based Buffer Overflow in the function rdp_in_unistr() and results in memory corruption and possibly even a remote code execution.</Description>
    <URL>https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow, via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-20179" CVSS="9.8">
    <Description>rdesktop versions up to and including v1.8.3 contain an Integer Underflow that leads to a Heap-Based Buffer Overflow in the function lspci_process() and results in memory corruption and probably even a remote code execution.</Description>
    <URL>https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow, via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-20180" CVSS="9.8">
    <Description>rdesktop versions up to and including v1.8.3 contain an Integer Underflow that leads to a Heap-Based Buffer Overflow in the function rdpsnddbg_process() and results in memory corruption and probably even a remote code execution.</Description>
    <URL>https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow, via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-20181" CVSS="9.8">
    <Description>rdesktop versions up to and including v1.8.3 contain an Integer Underflow that leads to a Heap-Based Buffer Overflow in the function seamless_process() and results in memory corruption and probably even a remote code execution.</Description>
    <URL>https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow, via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-20406" CVSS="7.5">
    <Description>Modules/_pickle.c in Python before 3.7.1 has an integer overflow via a large LONG_BINPUT value that is mishandled during a "resize to twice the size" attempt. This issue might cause memory exhaustion, but is only relevant if the pickle format is used for serializing tens or hundreds of gigabytes of data. This issue is fixed in: v3.4.10, v3.4.10rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.7rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.7, v3.6.7rc1, v3.6.7rc2, v3.6.8, v3.6.8rc1, v3.6.9, v3.6.9rc1; v3.7.1, v3.7.1rc1, v3.7.1rc2, v3.7.2, v3.7.2rc1, v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.</Description>
    <URL>https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-20545" CVSS="8.8">
    <Description>There is an illegal WRITE memory access at common-image.c (function load_image) in libcaca 0.99.beta19 for 4bpp data.</Description>
    <URL>https://github.com/cacalabs/libcaca/commit/3e52dabe3e64dc50f4422effe364a1457a8a8592</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-20546" CVSS="8.1">
    <Description>There is an illegal READ memory access at caca/dither.c (function get_rgba_default) in libcaca 0.99.beta19 for the default bpp case.</Description>
    <URL>https://github.com/cacalabs/libcaca/commit/1022d97496c7899e8641515af363381b31ae2f05</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-20820" CVSS="5.5">
    <Description>read_ujpg in jpgcoder.cc in Dropbox Lepton 1.2.1 allows attackers to cause a denial-of-service (application runtime crash because of an integer overflow) via a crafted file.</Description>
    <URL>https://github.com/dropbox/lepton/commit/6a5ceefac1162783fffd9506a3de39c85c725761</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-20847" CVSS="8.8">
    <Description>An improper computation of p_tx0, p_tx1, p_ty0 and p_ty1 in the function opj_get_encoding_parameters in openjp2/pi.c in OpenJPEG through 2.3.0 can lead to an integer overflow.</Description>
    <URL>https://github.com/uclouvain/openjpeg/commit/5d00b719f4b93b1445e6fb4c766b9a9883c57949</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-21009" CVSS="8.8">
    <Description>Poppler before 0.66.0 has an integer overflow in Parser::makeStream in Parser.cc.</Description>
    <URL>https://gitlab.freedesktop.org/poppler/poppler/commit/0868c499a9f5f37f8df5c9fef03c37496b40fc8a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-3577" CVSS="7.5">
    <Description>While processing fragments, when the fragment count becomes very large, an integer overflow leading to a buffer overflow can occur in Android releases from CAF using the linux kernel (Android for MSM, Firefox OS for MSM, QRD Android) before security patch level 2018-06-05.</Description>
    <URL>https://source.codeaurora.org/quic/la/platform/vendor/qcom-opensource/wlan/qcacld-2.0/commit/?id=cf1c43ce8840021d2907afaa6c514e6971d7ebac</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-3719" CVSS="8.8">
    <Description>mixin-deep node module before 1.3.1 suffers from a Modification of Assumed-Immutable Data (MAID) vulnerability, which allows a malicious user to modify the prototype of "Object" via __proto__, causing the addition or modification of an existing property that will exist on all objects.</Description>
    <URL>https://github.com/jonschlinkert/mixin-deep/commit/578b0bc5e74e14de9ef4975f504dc698796bdf9c</URL>
    <CWE CWE="20">
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Type" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Type" />
    </CWE>
    <CWE CWE="471">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" Consequence="Wrong Access Object" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-3720" CVSS="8.8">
    <Description>assign-deep node module before 0.4.7 suffers from a Modification of Assumed-Immutable Data (MAID) vulnerability, which allows a malicious user to modify the prototype of "Object" via __proto__, causing the addition or modification of an existing property that will exist on all objects.</Description>
    <URL>https://github.com/jonschlinkert/assign-deep/commit/19953a8c089b0328c470acaaaf6accdfcb34da11</URL>
    <CWE CWE="471">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" Consequence="Wrong Access Object" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-3721" CVSS="6.5">
    <Description>lodash node module before 4.17.5 suffers from a Modification of Assumed-Immutable Data (MAID) vulnerability via defaultsDeep, merge, and mergeWith functions, which allows a malicious user to modify the prototype of "Object" via __proto__, causing the addition or modification of an existing property that will exist on all objects.</Description>
    <URL>https://github.com/lodash/lodash/commit/d8e069cc3410082e44eb18fcf8e7f3d08ebe1d4a</URL>
    <CWE CWE="471">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" Consequence="Wrong Access Object" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-3722" CVSS="8.8">
    <Description>merge-deep node module before 3.0.1 suffers from a Modification of Assumed-Immutable Data (MAID) vulnerability, which allows a malicious user to modify the prototype of "Object" via __proto__, causing the addition or modification of an existing property that will exist on all objects.</Description>
    <URL>https://github.com/jonschlinkert/merge-deep/commit/2c33634da7129a5aefcc262d2fec2e72224404e5</URL>
    <CWE CWE="471">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" Consequence="Wrong Access Object" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-3723" CVSS="8.8">
    <Description>defaults-deep node module before 0.2.4 suffers from a Modification of Assumed-Immutable Data (MAID) vulnerability, which allows a malicious user to modify the prototype of "Object" via __proto__, causing the addition or modification of an existing property that will exist on all objects.</Description>
    <URL>https://github.com/jonschlinkert/defaults-deep/commit/c873f341327ad885ff4d0f23b3d3bca31b0343e5</URL>
    <CWE CWE="20">
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Type" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Type" />
    </CWE>
    <CWE CWE="471">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" Consequence="Wrong Access Object" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-3728" CVSS="8.8">
    <Description>hoek node module before 4.2.0 and 5.0.x before 5.0.3 suffers from a Modification of Assumed-Immutable Data (MAID) vulnerability via 'merge' and 'applyToDefaults' functions, which allows a malicious user to modify the prototype of "Object" via __proto__, causing the addition or modification of an existing property that will exist on all objects.</Description>
    <URL>https://github.com/hapijs/hoek/commit/32ed5c9413321fbc37da5ca81a7cbab693786dee</URL>
    <CWE CWE="471">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" Consequence="Wrong Access Object" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-5800" CVSS="6.5">
    <Description>An off-by-one error within the "LibRaw::kodak_ycbcr_load_raw()" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.</Description>
    <URL>https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-5804" CVSS="6.5">
    <Description>A type confusion error within the "identify()" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.8 can be exploited to trigger a division by zero.</Description>
    <URL>https://github.com/LibRaw/LibRaw/commit/9f26ce37f5be86ea11bfc6831366558650b1f6ff</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-5815" CVSS="6.5">
    <Description>An integer overflow error within the "parse_qt()" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.12 can be exploited to trigger an infinite loop via a specially crafted Apple QuickTime file.</Description>
    <URL>https://github.com/LibRaw/LibRaw/commit/1334647862b0c90b2e8cb2f668e66627d9517b17</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Infinite Loop">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-5816" CVSS="6.5">
    <Description>An integer overflow error within the "identify()" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.12 can be exploited to trigger a division by zero via specially crafted NOKIARAW file (Note: This vulnerability is caused due to an incomplete fix of CVE-2018-5804).</Description>
    <URL>https://github.com/LibRaw/LibRaw/commit/1d8d1b452e5dc74033ee9f846081a0efb616cc39</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-5865" CVSS="5.5">
    <Description>While processing a debug log event from firmware in all Android releases from CAF using the Linux kernel (Android for MSM, Firefox OS for MSM, QRD Android) before security patch level 2018-07-05, an integer underflow and/or buffer over-read can occur.</Description>
    <URL>https://source.codeaurora.org/quic/la/platform/vendor/qcom-opensource/wlan/qcacld-3.0/commit/?id=8fb4202e3bb8cfbbb9f9f0e8695891c9971cfcc2</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2018-6927" CVSS="7.8">
    <Description>The futex_requeue function in kernel/futex.c in the Linux kernel before 4.14.15 might allow attackers to cause a denial of service (integer overflow) or possibly have unspecified other impact by triggering a negative wake or requeue value.</Description>
    <URL>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=fbe0e839d1e22d88810f3ee3e2f1479be4c0aa4a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-8098" CVSS="6.5">
    <Description>Integer overflow in the index.c:read_entry() function while decompressing a compressed prefix length in libgit2 before v0.26.2 allows an attacker to cause a denial of service (out-of-bounds read) via a crafted repository index file.</Description>
    <URL>https://github.com/libgit2/libgit2/commit/3207ddb0103543da8ad2139ec6539f590f9900c1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-8786" CVSS="9.8">
    <Description>FreeRDP prior to version 2.0.0-rc4 contains an Integer Truncation that leads to a Heap-Based Buffer Overflow in function update_read_bitmap_update() and results in a memory corruption and probably even a remote code execution.</Description>
    <URL>https://github.com/FreeRDP/FreeRDP/commit/445a5a42c500ceb80f8fa7f2c11f3682538033f3</URL>
    <CWE CWE="680">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow, via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-8787" CVSS="9.8">
    <Description>FreeRDP prior to version 2.0.0-rc4 contains an Integer Overflow that leads to a Heap-Based Buffer Overflow in function gdi_Bitmap_Decompress() and results in a memory corruption and probably even a remote code execution.</Description>
    <URL>https://github.com/FreeRDP/FreeRDP/commit/09b9d4f1994a674c4ec85b4947aa656eda1aed8a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="680">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow, via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-8794" CVSS="9.8">
    <Description>rdesktop versions up to and including v1.8.3 contain an Integer Overflow that leads to an Out-Of-Bounds Write in function process_bitmap_updates() and results in a memory corruption and possibly even a remote code execution.</Description>
    <URL>https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="680">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-8795" CVSS="9.8">
    <Description>rdesktop versions up to and including v1.8.3 contain an Integer Overflow that leads to a Heap-Based Buffer Overflow in function process_bitmap_updates() and results in a memory corruption and probably even a remote code execution.</Description>
    <URL>https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="680">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow, via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2018-8828" CVSS="9.8">
    <Description>A Buffer Overflow issue was discovered in Kamailio before 4.4.7, 5.0.x before 5.0.6, and 5.1.x before 5.1.2. A specially crafted REGISTER message with a malformed branch or From tag triggers an off-by-one heap-based buffer overflow in the tmx_check_pretran function in modules/tmx/tmx_pretran.c.</Description>
    <URL>https://github.com/kamailio/kamailio/commit/e1d8008a09d9390ebaf698abe8909e10dfec4097</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-1010065" CVSS="6.5">
    <Description>The Sleuth Kit 4.6.0 and earlier is affected by: Integer Overflow. The impact is: Opening crafted disk image triggers crash in tsk/fs/hfs_dent.c:237. The component is: Overflow in fls tool used on HFS image. Bug is in tsk/fs/hfs.c file in function hfs_cat_traverse() in lines: 952, 1062. The attack vector is: Victim must open a crafted HFS filesystem image.</Description>
    <URL>https://github.com/sleuthkit/sleuthkit/commit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2019-1010296" CVSS="9.8">
    <Description>Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Code execution in context of TEE core (kernel). The component is: optee_os. The fixed version is: 3.4.0 and later.</Description>
    <URL>https://github.com/OP-TEE/optee_os/commit/b60e1cee406a1ff521145ab9534370dfb85dd592</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-1010297" CVSS="9.8">
    <Description>Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Execution of code in TEE core (kernel) context. The component is: optee_os. The fixed version is: 3.4.0 and later.</Description>
    <URL>https://github.com/OP-TEE/optee_os/commit/a637243270fc1faae16de059091795c32d86e65e</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-1010298" CVSS="9.8">
    <Description>Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Code execution in the context of TEE core (kernel). The component is: optee_os. The fixed version is: 3.4.0 and later.</Description>
    <URL>https://github.com/OP-TEE/optee_os/commit/70697bf3c5dc3d201341b01a1a8e5bc6d2fb48f8</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-1010315" CVSS="5.5">
    <Description>WavPack 5.1 and earlier is affected by: CWE 369: Divide by Zero. The impact is: Divide by zero can lead to sudden crash of a software/service that tries to parse a .wav file. The component is: ParseDsdiffHeaderConfig (dsdiff.c:282). The attack vector is: Maliciously crafted .wav file. The fixed version is: After commit https://github.com/dbry/WavPack/commit/4c0faba32fddbd0745cbfaf1e1aeb3da5d35b9fc.</Description>
    <URL>https://github.com/dbry/WavPack/commit/4c0faba32fddbd0745cbfaf1e1aeb3da5d35b9fc</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-10131" CVSS="7.1">
    <Description>An off-by-one read vulnerability was discovered in ImageMagick before version 7.0.7-28 in the formatIPTCfromBuffer function in coders/meta.c. A local attacker may use this flaw to read beyond the end of the buffer or to crash the program.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/cb1214c124e1bd61f7dd551b94a794864861592e</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2019-11072" CVSS="9.8">
    <Description>lighttpd before 1.4.54 has a signed integer overflow, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a malicious HTTP GET request, as demonstrated by mishandling of /%2F? in burl_normalize_2F_to_slash_fix in burl.c. NOTE: The developer states "The feature which can be abused to cause the crash is a new feature in lighttpd 1.4.50, and is not enabled by default. It must be explicitly configured in the config file (e.g. lighttpd.conf). Certain input will trigger an abort() in lighttpd when that feature is enabled. lighttpd detects the underflow or realloc() will fail (in both 32-bit and 64-bit executables), also detected in lighttpd. Either triggers an explicit abort() by lighttpd. This is not exploitable beyond triggering the explicit abort() with subsequent application exit.</Description>
    <URL>https://github.com/lighttpd/lighttpd1.4/commit/32120d5b8b3203fc21ccb9eafb0eaf824bb59354</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-11472" CVSS="6.5">
    <Description>ReadXWDImage in coders/xwd.c in the XWD image parsing component of ImageMagick 7.0.8-41 Q16 allows attackers to cause a denial-of-service (divide-by-zero error) by crafting an XWD image file in which the header indicates neither LSB first nor MSB first.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick6/commit/f663dfb8431c97d95682a2b533cca1c8233d21b4</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-11477" CVSS="7.5">
    <Description>Jonathan Looney discovered that the TCP_SKB_CB(skb)-&gt;tcp_gso_segs value was subject to an integer overflow in the Linux kernel when handling TCP Selective Acknowledgments (SACKs). A remote attacker could use this to cause a denial of service. This has been fixed in stable kernel releases 4.4.182, 4.9.182, 4.14.127, 4.19.52, 5.1.11, and is fixed in commit 3b4929f65b0d8249f19a50245cd88ed1a2f78cff.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?id=3b4929f65b0d8249f19a50245cd88ed1a2f78cff</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-12980" CVSS="6.5">
    <Description>In Ming (aka libming) 0.4.8, there is an integer overflow (caused by an out-of-range left shift) in the SWFInput_readSBits function in blocks/input.c. Remote attackers could leverage this vulnerability to cause a denial-of-service via a crafted swf file.</Description>
    <URL>https://github.com/libming/libming/commit/a009a38dce1d9316cad1ab522b813b1d5ba4c62a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-13136" CVSS="7.8">
    <Description>ImageMagick before 7.0.8-50 has an integer overflow vulnerability in the function TIFFSeekCustomStream in coders/tiff.c.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/fe5f4b85e6b1b54d3b4588a77133c06ade46d891</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2019-13218" CVSS="5.5">
    <Description>Division by zero in the predict_point function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service by opening a crafted Ogg Vorbis file.</Description>
    <URL>https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-13305" CVSS="7.8">
    <Description>ImageMagick 7.0.8-50 Q16 has a stack-based buffer overflow at coders/pnm.c in WritePNMImage because of a misplaced strncpy and an off-by-one error.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/29efd648f38b73a64d73f14cd2019d869a585888</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-13306" CVSS="7.8">
    <Description>ImageMagick 7.0.8-50 Q16 has a stack-based buffer overflow at coders/pnm.c in WritePNMImage because of off-by-one errors.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/e92040ea6ee2a844ebfd2344174076795a4787bd</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-13454" CVSS="6.5">
    <Description>ImageMagick 7.0.8-54 Q16 allows Division by Zero in RemoveDuplicateLayers in MagickCore/layer.c.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/1ddcf2e4f28029a888cadef2e757509ef5047ad8</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-14283" CVSS="6.8">
    <Description>In the Linux kernel before 5.2.3, set_geometry in drivers/block/floppy.c does not validate the sect and head fields, as demonstrated by an integer overflow and out-of-bounds read. It can be triggered by an unprivileged local user when a floppy disk has been inserted. NOTE: QEMU creates the floppy device by default.</Description>
    <URL>https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=da99466ac243f15fbba65bd261bfc75ffa1532b6</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2019-14284" CVSS="6.2">
    <Description>In the Linux kernel before 5.2.3, drivers/block/floppy.c allows a denial of service by setup_format_params division-by-zero. Two consecutive ioctls can trigger the bug: the first one should set the drive geometry with .sect and .rate values that make F_SECT_PER_TRACK be zero. Next, the floppy format operation should be called. It can be triggered by an unprivileged local user even when a floppy disk has not been inserted. NOTE: QEMU creates the floppy device by default.</Description>
    <URL>https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f3554aeb991214cbfafd17d55e2bfddb50282e32</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-14323" CVSS="7.5">
    <Description>SSDP Responder 1.x through 1.5 mishandles incoming network messages, leading to a stack-based buffer overflow by 1 byte. This results in a crash of the server, but only when strict stack checking is enabled. This is caused by an off-by-one error in ssdp_recv in ssdpd.c.</Description>
    <URL>https://github.com/troglobit/ssdp-responder/commit/ce04b1f29a137198182f60bbb628d5ceb8171765</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-14459" CVSS="7.5">
    <Description>nfdump 1.6.17 and earlier is affected by an integer overflow in the function Process_ipfix_template_withdraw in ipfix.c that can be abused in order to crash the process remotely (denial of service).</Description>
    <URL>https://github.com/phaag/nfdump/commit/3b006ededaf351f1723aea6c727c9edd1b1fff9b</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-14981" CVSS="6.5">
    <Description>In ImageMagick 7.x before 7.0.8-41 and 6.x before 6.9.10-41, there is a divide-by-zero vulnerability in the MeanShiftImage function. It allows an attacker to cause a denial of service by sending a crafted file.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/a77d8d97f5a7bced0468f0b08798c83fb67427bc</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-15161" CVSS="5.3">
    <Description>rpcapd/daemon.c in libpcap before 1.9.1 mishandles certain length values because of reuse of a variable. This may open up an attack vector involving extra data at the end of a request.</Description>
    <URL>https://github.com/the-tcpdump-group/libpcap/commit/617b12c0339db4891d117b661982126c495439ea</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2019-15791" CVSS="7.8">
    <Description>In shiftfs, a non-upstream patch to the Linux kernel included in the Ubuntu 5.0 and 5.3 kernel series, shiftfs_btrfs_ioctl_fd_replace() installs an fd referencing a file from the lower filesystem without taking an additional reference to that file. After the btrfs ioctl completes this fd is closed, which then puts a reference to that file, leading to a refcount underflow.</Description>
    <URL>https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/eoan/commit/?id=601a64857b3d7040ca15c39c929e6b9db3373ec1</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="672">
      <MainWeakness Cause="Dangling Pointer" Operation="Read" Consequence="Use After Deallocate" />
      <MainWeakness Cause="Dangling Pointer" Operation="Reallocate-Reduce" Consequence="Double Deallocate" />
      <MainWeakness Cause="Dangling Pointer" Operation="Write" Consequence="Use After Deallocate" />
      <MainWeakness Cause="Dangling Pointer" Operation="Dereference" Consequence="Use After Deallocate" />
      <MainWeakness Cause="Dangling Pointer" Operation="Deallocate" Consequence="Double Deallocate" />
      <MainWeakness Cause="Dangling Pointer" Operation="Reallocate-Extend" Consequence="Double Deallocate" />
      <MainWeakness Cause="Dangling Pointer" Operation="Reduce" Consequence="Double Deallocate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2019-16346" CVSS="8.8">
    <Description>ngiflib 0.4 has a heap-based buffer overflow in WritePixel() in ngiflib.c when called from DecodeGifImg, because deinterlacing for small pictures is mishandled.</Description>
    <URL>https://github.com/miniupnp/ngiflib/commit/37d939a6f511d16d4c95678025c235fe62e6417a</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-16347" CVSS="8.8">
    <Description>ngiflib 0.4 has a heap-based buffer overflow in WritePixels() in ngiflib.c when called from DecodeGifImg, because deinterlacing for small pictures is mishandled.</Description>
    <URL>https://github.com/miniupnp/ngiflib/commit/37d939a6f511d16d4c95678025c235fe62e6417a</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-16778" CVSS="9.8">
    <Description>In TensorFlow before 1.15, a heap buffer overflow in UnsortedSegmentSum can be produced when the Index template argument is int32. In this case data_size and num_segments fields are truncated from int64 to int32 and can produce negative numbers, resulting in accessing out of bounds heap memory. This is unlikely to be exploitable and was detected and fixed internally in TensorFlow 1.15 and 2.0.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/db4f9717c41bccc3ce10099ab61996b246099892</URL>
    <CWE CWE="122">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
    </CWE>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-17498" CVSS="8.1">
    <Description>In libssh2 v1.9.0 and earlier versions, the SSH_MSG_DISCONNECT logic in packet.c has an integer overflow in a bounds check, enabling an attacker to specify an arbitrary (out-of-bounds) offset for a subsequent memory read. A crafted SSH server may be able to disclose sensitive information or cause a denial of service condition on the client system when a user connects to the server.</Description>
    <URL>https://github.com/libssh2/libssh2/commit/dedcbd106f8e52d5586b0205bc7677e4c9868f9c</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-17546" CVSS="8.8">
    <Description>tif_getimage.c in LibTIFF through 4.0.10, as used in GDAL through 3.0.1 and other products, has an integer overflow that potentially causes a heap-based buffer overflow via a crafted RGBA image, related to a "Negative-size-param" condition.</Description>
    <URL>https://github.com/OSGeo/gdal/commit/21674033ee246f698887604c7af7ba1962a40ddf</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-18675" CVSS="7.8">
    <Description>The Linux kernel through 5.3.13 has a start_offset+size Integer Overflow in cpia2_remap_buffer in drivers/media/usb/cpia2/cpia2_core.c because cpia2 has its own mmap implementation. This allows local users (with /dev/video0 access) to obtain read and write permissions on kernel physical pages, which can possibly result in a privilege escalation.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=be83bbf806822b1b89e0a0f23cd87cddc409e429</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2019-18805" CVSS="9.8">
    <Description>An issue was discovered in net/ipv4/sysctl_net_ipv4.c in the Linux kernel before 5.0.11. There is a net/ipv4/tcp_input.c signed integer overflow in tcp_ack_update_rtt() when userspace writes a very large integer to /proc/sys/net/ipv4/tcp_min_rtt_wlen, leading to a denial of service or possibly unspecified other impact, aka CID-19fad20d15a6.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=19fad20d15a6494f47f85d869f00b11343ee5c78</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-19317" CVSS="9.8">
    <Description>lookupName in resolve.c in SQLite 3.30.1 omits bits from the colUsed bitmask in the case of a generated column, which allows attackers to cause a denial of service or possibly have unspecified other impact.</Description>
    <URL>https://github.com/sqlite/sqlite/commit/522ebfa7cee96fb325a22ea3a2464a63485886a8</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-20788" CVSS="9.8">
    <Description>libvncclient/cursor.c in LibVNCServer through 0.9.12 has a HandleCursorShape integer overflow and heap-based buffer overflow via a large height or width value. NOTE: this may overlap CVE-2019-15690.</Description>
    <URL>https://github.com/LibVNC/libvncserver/commit/54220248886b5001fbbb9fa73c4e1a2cb9413fed</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-20805" CVSS="5.5">
    <Description>p_lx_elf.cpp in UPX before 3.96 has an integer overflow during unpacking via crafted values in a PT_DYNAMIC segment.</Description>
    <URL>https://github.com/upx/upx/commit/8be9da8280dfa69d5df4417d4d81bda1cab78010</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2019-3560" CVSS="7.5">
    <Description>An improperly performed length calculation on a buffer in PlaintextRecordLayer could lead to an infinite loop and denial-of-service based on user input. This issue affected versions of fizz prior to v2019.03.04.00.</Description>
    <URL>https://github.com/facebookincubator/fizz/commit/40bbb161e72fb609608d53b9d64c56bb961a6ee2</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure Comment="via Infinite Loop">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2019-9278" CVSS="8.8">
    <Description>In libexif, there is a possible out of bounds write due to an integer overflow. This could lead to remote escalation of privilege in the media content provider with no additional execution privileges needed. User interaction is needed for exploitation. Product: AndroidVersions: Android-10Android ID: A-112537774</Description>
    <URL>https://github.com/libexif/libexif/commit/75aa73267fdb1e0ebfbc00369e7312bac43d0566</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-10531" CVSS="8.8">
    <Description>An issue was discovered in International Components for Unicode (ICU) for C/C++ through 66.1. An integer overflow, leading to a heap-based buffer overflow, exists in the UnicodeString::doAppend() function in common/unistr.cpp.</Description>
    <URL>https://github.com/unicode-org/icu/commit/b7d08bc04a4296982fcef8b6b8a354a9e4e7afca</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-10543" CVSS="8.2">
    <Description>Perl before 5.30.3 on 32-bit platforms allows a heap-based buffer overflow because nested regular expression quantifiers have an integer overflow.</Description>
    <URL>https://github.com/perl/perl5/commit/897d1f7fd515b828e4b198d8b8bef76c6faf03ed</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-10878" CVSS="8.6">
    <Description>Perl before 5.30.3 has an integer overflow related to mishandling of a "PL_regkind[OP(n)] == NOTHING" situation. A crafted regular expression could lead to malformed bytecode with a possibility of instruction injection.</Description>
    <URL>https://github.com/perl/perl5/commit/0a320d753fe7fca03df259a4dfd8e641e51edaa8</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-11071" CVSS="8.6">
    <Description>SLPJS (npm package slpjs) before version 0.27.2, has a vulnerability where users could experience false-negative validation outcomes for MINT transaction operations. A poorly implemented SLP wallet could allow spending of the affected tokens which would result in the destruction of a user's minting baton. This is fixed in version 0.27.2.</Description>
    <URL>https://github.com/simpleledger/slpjs/commit/3671be2ffb6d4cfa94c00c6dc8649d1ba1d75754</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-11072" CVSS="8.6">
    <Description>In SLP Validate (npm package slp-validate) before version 1.2.1, users could experience false-negative validation outcomes for MINT transaction operations. A poorly implemented SLP wallet could allow spending of the affected tokens which would result in the destruction of a user's minting baton. This has been fixed in slp-validate in version 1.2.1. Additonally, slpjs version 0.27.2 has a related fix under related CVE-2020-11071.</Description>
    <URL>https://github.com/simpleledger/slp-validate/commit/cde95c0c6470dceb4f023cd462f904135ebd73e7</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-11939" CVSS="9.8">
    <Description>In nDPI through 3.2 Stable, the SSH protocol dissector has multiple KEXINIT integer overflows that result in a controlled remote heap overflow in concat_hash_string in ssh.c. Due to the granular nature of the overflow primitive and the ability to control both the contents and layout of the nDPI library's heap memory through remote input, this vulnerability may be abused to achieve full Remote Code Execution against any network inspection stack that is linked against nDPI and uses it to perform network traffic analysis.</Description>
    <URL>https://github.com/ntop/nDPI/commit/7ce478a58b4dd29a8d1e6f4e9df2f778613d9202</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-11945" CVSS="9.8">
    <Description>An issue was discovered in Squid before 5.0.2. A remote attacker can replay a sniffed Digest Authentication nonce to gain access to resources that are otherwise forbidden. This occurs because the attacker can overflow the nonce reference counter (a short integer). Remote code execution may occur if the pooled token credentials are freed (instead of replayed as valid credentials).</Description>
    <URL>https://github.com/squid-cache/squid/commit/eeebf0f37a72a2de08348e85ae34b02c34e9a811</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-12135" CVSS="5.5">
    <Description>bson before 0.8 incorrectly uses int rather than size_t for many variables, parameters, and return values. In particular, the bson_ensure_space() parameter bytesNeeded could have an integer overflow via properly constructed bson input.</Description>
    <URL>https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca#diff-f7d29a680148f52d6601f59ed787f577</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-12278" CVSS="9.8">
    <Description>An issue was discovered in libgit2 before 0.28.4 and 0.9x before 0.99.0. path.c mishandles equivalent filenames that exist because of NTFS Alternate Data Streams. This may allow remote code execution when cloning a repository. This issue is similar to CVE-2019-1352.</Description>
    <URL>https://github.com/libgit2/libgit2/commit/3f7851eadca36a99627ad78cbe56a40d3776ed01</URL>
    <CWE CWE="706">
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Object Resolved" />
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Function Resolved" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-12279" CVSS="9.8">
    <Description>An issue was discovered in libgit2 before 0.28.4 and 0.9x before 0.99.0. checkout.c mishandles equivalent filenames that exist because of NTFS short names. This may allow remote code execution when cloning a repository. This issue is similar to CVE-2019-1353.</Description>
    <URL>https://github.com/libgit2/libgit2/commit/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4</URL>
    <CWE CWE="706">
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Object Resolved" />
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Function Resolved" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-12761" CVSS="9.1">
    <Description>modules/loaders/loader_ico.c in imlib2 1.6.0 has an integer overflow (with resultant invalid memory allocations and out-of-bounds reads) via an icon with many colors in its color map.</Description>
    <URL>https://git.enlightenment.org/legacy/imlib2.git/commit/?id=c95f938ff1effaf91729c050a0f1c8684da4dd63</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-12826" CVSS="5.3">
    <Description>A signal access-control issue was discovered in the Linux kernel before 5.6.5, aka CID-7395ea4e65c2. Because exec_id in include/linux/sched.h is only 32 bits, an integer overflow can interfere with a do_notify_parent protection mechanism. A child process can send an arbitrary signal to a parent process in a different security domain. Exploitation limitations include the amount of elapsed time before an integer overflow occurs, and the lack of scenarios where signals to a parent process present a substantial operational threat.</Description>
    <URL>https://github.com/torvalds/linux/commit/7395ea4e65c2a00d23185a3f63ad315756ba9cef</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-12887" CVSS="7.5">
    <Description>Memory leaks were discovered in the CoAP library in Arm Mbed OS 5.15.3 when using the Arm mbed-coap library 5.1.5. The CoAP parser is responsible for parsing received CoAP packets. The function sn_coap_parser_options_parse() parses the CoAP option number field of all options present in the input packet. Each option number is calculated as a sum of the previous option number and a delta of the current option. The delta and the previous option number are expressed as unsigned 16-bit integers. Due to lack of overflow detection, it is possible to craft a packet that wraps the option number around and results in the same option number being processed again in a single packet. Certain options allocate memory by calling a memory allocation function. In the cases of COAP_OPTION_URI_QUERY, COAP_OPTION_URI_PATH, COAP_OPTION_LOCATION_QUERY, and COAP_OPTION_ETAG, there is no check on whether memory has already been allocated, which in conjunction with the option number integer overflow may lead to multiple assignments of allocated memory to a single pointer. This has been demonstrated to lead to memory leak by buffer orphaning. As a result, the memory is never freed.</Description>
    <URL>https://github.com/mjurczak/mbed-coap/commit/4647a68e364401e81dbd370728127d844f221d93</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="401">
      <MainWeakness Cause="Single Owned Address" Operation="Reassign" Consequence="Memory Leak" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-13974" CVSS="7.8">
    <Description>An issue was discovered in the Linux kernel 4.4 through 5.7.1. drivers/tty/vt/keyboard.c has an integer overflow if k_ascii is called several times in a row, aka CID-b86dab054059. NOTE: Members in the community argue that the integer overflow does not lead to a security issue in this case.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=dad0bf9ce93fa40b667eccd3306783f4db4b932b</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-14147" CVSS="7.7">
    <Description>An integer overflow in the getnum function in lua_struct.c in Redis before 6.0.3 allows context-dependent attackers with permission to run Lua code in a Redis session to cause a denial of service (memory corruption and application crash) or possibly bypass intended sandbox restrictions via a large number, which triggers a stack-based buffer overflow. NOTE: this issue exists because of a CVE-2015-8080 regression.</Description>
    <URL>https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow, via Memory Corruption">Data Tempering (TPR)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-14385" CVSS="5.5">
    <Description>A flaw was found in the Linux kernel before 5.9-rc4. A failure of the file system metadata validator in XFS can cause an inode with a valid, user-creatable extended attribute to be flagged as corrupt. This can lead to the filesystem being shutdown, or otherwise rendered inaccessible until it is remounted, leading to a denial of service. The highest threat from this vulnerability is to system availability.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f4020438fab05364018c91f7e02ebdd192085933</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-14401" CVSS="6.5">
    <Description>An issue was discovered in LibVNCServer before 0.9.13. libvncserver/scale.c has a pixel_value integer overflow.</Description>
    <URL>https://github.com/LibVNC/libvncserver/commit/a6788d1da719ae006605b78d22f5a9f170b423af</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-15130" CVSS="7.5">
    <Description>In SLPJS (npm package slpjs) before version 0.27.4, there is a vulnerability to false-positive validation outcomes for the NFT1 Child Genesis transaction type. A poorly implemented SLP wallet or opportunistic attacker could create a seemingly valid NFT1 child token without burning any of the NFT1 Group token type as is required by the NFT1 specification. This is fixed in version 0.27.4.</Description>
    <URL>https://github.com/simpleledger/slpjs/commit/290c20e8bff13ac81459d43e54cac232b5e3456c</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-15131" CVSS="7.5">
    <Description>In SLP Validate (npm package slp-validate) before version 1.2.2, there is a vulnerability to false-positive validation outcomes for the NFT1 Child Genesis transaction type. A poorly implemented SLP wallet or opportunistic attacker could create a seemingly valid NFT1 child token without burning any of the NFT1 Group token type as is required by the NFT1 specification. This is fixed in version 1.2.2.</Description>
    <URL>https://github.com/simpleledger/slp-validate.js/commit/3963cf914afae69084059b82483da916d97af65c</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-15158" CVSS="9.8">
    <Description>In libIEC61850 before version 1.4.3, when a message with COTP message length field with value &lt; 4 is received an integer underflow will happen leading to heap buffer overflow. This can cause an application crash or on some platforms even the execution of remote code. If your application is used in open networks or there are untrusted nodes in the network it is highly recommend to apply the patch. This was patched with commit 033ab5b. Users of version 1.4.x should upgrade to version 1.4.3 when available. As a workaround changes of commit 033ab5b can be applied to older versions.</Description>
    <URL>https://github.com/mz-automation/libiec61850/commit/033ab5b6488250c8c3b838f25a7cbc3e099230bb</URL>
    <CWE CWE="119">
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="122">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
    </CWE>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-15185" CVSS="2.7">
    <Description>In Helm before versions 2.16.11 and 3.3.2, a Helm repository can contain duplicates of the same chart, with the last one always used. If a repository is compromised, this lowers the level of access that an attacker needs to inject a bad chart into a repository. To perform this attack, an attacker must have write access to the index file (which can occur during a MITM attack on a non-SSL connection). This issue has been patched in Helm 3.3.2 and 2.16.11. A possible workaround is to manually review the index file in the Helm repository cache before installing software.</Description>
    <URL>https://github.com/helm/helm/commit/055dd41cbe53ce131ab0357524a7f6729e6e40dc</URL>
    <CWE CWE="74">
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Source Code Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Command Injection" />
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Query Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Parameter Injection" />
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="File Injection" />
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Parameter Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="File Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Query Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Source Code Injection" />
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Command Injection" />
    </CWE>
    <CWE CWE="694">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-15187" CVSS="4.7">
    <Description>In Helm before versions 2.16.11 and 3.3.2, a Helm plugin can contain duplicates of the same entry, with the last one always used. If a plugin is compromised, this lowers the level of access that an attacker needs to modify a plugin's install hooks, causing a local execution attack. To perform this attack, an attacker must have write access to the git repository or plugin archive (.tgz) while being downloaded (which can occur during a MITM attack on a non-SSL connection). This issue has been patched in Helm 2.16.11 and Helm 3.3.2. As a possible workaround make sure to install plugins using a secure connection protocol like SSL.</Description>
    <URL>https://github.com/helm/helm/commit/d9ef5ce8bad512e325390c0011be1244b8380e4b</URL>
    <CWE CWE="74">
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Source Code Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Command Injection" />
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Query Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Parameter Injection" />
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="File Injection" />
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Parameter Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="File Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Query Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Source Code Injection" />
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Command Injection" />
    </CWE>
    <CWE CWE="694">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-15225" CVSS="6.5">
    <Description>django-filter is a generic system for filtering Django QuerySets based on user selections. In django-filter before version 2.4.0, automatically generated `NumberFilter` instances, whose value was later converted to an integer, were subject to potential DoS from maliciously input using exponential format with sufficiently large exponents. Version 2.4.0+ applies a `MaxValueValidator` with a a default `limit_value` of 1e50 to the form field used by `NumberFilter` instances. In addition, `NumberFilter` implements the new `get_max_validator()` which should return a configured validator instance to customise the limit, or else `None` to disable the additional validation. Users may manually apply an equivalent validator if they are not able to upgrade.</Description>
    <URL>https://github.com/carltongibson/django-filter/commit/340cf7a23a2b3dcd7183f6a0d6c383e85b130d2b</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-15256" CVSS="9.8">
    <Description>A prototype pollution vulnerability has been found in `object-path` &lt;= 0.11.4 affecting the `set()` method. The vulnerability is limited to the `includeInheritedProps` mode (if version &gt;= 0.11.0 is used), which has to be explicitly enabled by creating a new instance of `object-path` and setting the option `includeInheritedProps: true`, or by using the default `withInheritedProps` instance. The default operating mode is not affected by the vulnerability if version &gt;= 0.11.0 is used. Any usage of `set()` in versions &lt; 0.11.0 is vulnerable. The issue is fixed in object-path version 0.11.5 As a workaround, don't use the `includeInheritedProps: true` options or the `withInheritedProps` instance if using a version &gt;= 0.11.0.</Description>
    <URL>https://github.com/mariocasciaro/object-path/commit/2be3354c6c46215c7635eb1b76d80f1319403c68</URL>
    <CWE CWE="20">
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Type" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Type" />
    </CWE>
    <CWE CWE="471">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" Consequence="Wrong Access Object" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-15900" CVSS="9.8">
    <Description>A memory corruption issue was found in Artifex Ghostscript 9.50 and 9.52. Use of a non-standard PostScript operator can allow overriding of file access controls. The 'rsearch' calculation for the 'post' size resulted in a size that was too large, and could underflow to max uint32_t. This was fixed in commit 5d499272b95a6b890a1397e11d20937de000d31b.</Description>
    <URL>https://github.com/ArtifexSoftware/ghostpdl/commit/5d499272b95a6b890a1397e11d20937de000d31b</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-1913" CVSS="8.1">
    <Description>An Integer signedness error in the JavaScript Interpreter in Facebook Hermes prior to commit 2c7af7ec481ceffd0d14ce2d7c045e475fd71dc6 allows attackers to cause a denial of service attack or a potential RCE via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.</Description>
    <URL>https://github.com/facebook/hermes/commit/2c7af7ec481ceffd0d14ce2d7c045e475fd71dc6</URL>
    <CWE CWE="195">
      <MainWeakness Cause="Erroneous Code" Operation="Coerce" Consequence="Wrong Value" />
    </CWE>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-1920" CVSS="7.5">
    <Description>A regular expression denial of service (ReDoS) vulnerability in the validateBaseUrl function can cause the application to use excessive resources, become unresponsive, or crash. This was introduced in react-native version 0.59.0 and fixed in version 0.64.1.</Description>
    <URL>https://github.com/facebook/react-native/commit/ca09ae82715e33c9ac77b3fa55495cf84ba891c7</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-19490" CVSS="5.5">
    <Description>tinyexr 0.9.5 has a integer overflow over-write in tinyexr::DecodePixelData in tinyexr.h, related to OpenEXR code.</Description>
    <URL>https://github.com/syoyo/tinyexr/commit/a685e3332f61cd4e59324bf3f669d36973d64270</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-19497" CVSS="8.8">
    <Description>Integer overflow vulnerability in Mat_VarReadNextInfo5 in mat5.c in tbeu matio (aka MAT File I/O Library) 1.5.17, allows attackers to cause a Denial of Service or possibly other unspecified impacts.</Description>
    <URL>https://github.com/tbeu/matio/commit/5fa49ef9fc4368fe3d19b5fdaa36d8fa5e7f4606</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-20898" CVSS="8.8">
    <Description>Integer Overflow vulnerability in function filter16_prewitt in libavfilter/vf_convolution.c in Ffmpeg 4.2.1, allows attackers to cause a Denial of Service or other unspecified impacts.</Description>
    <URL>https://git.ffmpeg.org/gitweb/ffmpeg.git/commit/99f8d32129dd233d4eb2efa44678a0bc44869f23</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-22784" CVSS="7.5">
    <Description>In Etherpad UeberDB &lt; 0.4.4, due to MySQL omitting trailing spaces on char / varchar columns during comparisons, retrieving database records using UeberDB's MySQL connector could allow bypassing access controls enforced on key names.</Description>
    <URL>https://github.com/ether/ueberDB/commit/e8b58d03534ade8d83c2d1946a8350a23952531e</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-22874" CVSS="9.8">
    <Description>Integer overflow vulnerability in function Jsi_ObjArraySizer in jsish before 3.0.8, allows remote attackers to execute arbitrary code.</Description>
    <URL>https://github.com/pcmacdon/jsish/commit/858da537bde4de9d8c92466d5a866505310bc328</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-22875" CVSS="9.8">
    <Description>Integer overflow vulnerability in function Jsi_ObjSetLength in jsish before 3.0.6, allows remote attackers to execute arbitrary code.</Description>
    <URL>https://github.com/pcmacdon/jsish/commit/5408a6d93f45bf1f7acd9ae5d44e0ebd77379e98</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-24370" CVSS="5.3">
    <Description>ldebug.c in Lua 5.4.0 allows a negation overflow and segmentation fault in getlocal and setlocal, as demonstrated by getlocal(3,2^31).</Description>
    <URL>https://github.com/lua/lua/commit/a585eae6e7ada1ca9271607a4f48dfb17868ab7b</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-26233" CVSS="7.3">
    <Description>Git Credential Manager Core (GCM Core) is a secure Git credential helper built on .NET Core that runs on Windows and macOS. In Git Credential Manager Core before version 2.0.289, when recursively cloning a Git repository on Windows with submodules, Git will first clone the top-level repository and then recursively clone all submodules by starting new Git processes from the top-level working directory. If a malicious git.exe executable is present in the top-level repository then this binary will be started by Git Credential Manager Core when attempting to read configuration, and not git.exe as found on the %PATH%. This only affects GCM Core on Windows, not macOS or Linux-based distributions. GCM Core version 2.0.289 contains the fix for this vulnerability, and is available from the project's GitHub releases page. GCM Core 2.0.289 is also bundled in the latest Git for Windows release; version 2.29.2(3). As a workaround, users should avoid recursively cloning untrusted repositories with the --recurse-submodules option.</Description>
    <URL>https://github.com/microsoft/Git-Credential-Manager-Core/commit/61c0388e064babb3b4e60d3ec269e8a07ab3bc76</URL>
    <CWE CWE="706">
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Object Resolved" />
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Function Resolved" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-26237" CVSS="8.7">
    <Description>Highlight.js is a syntax highlighter written in JavaScript. Highlight.js versions before 9.18.2 and 10.1.2 are vulnerable to Prototype Pollution. A malicious HTML code block can be crafted that will result in prototype pollution of the base object's prototype during highlighting. If you allow users to insert custom HTML code blocks into your page/app via parsing Markdown code blocks (or similar) and do not filter the language names the user can provide you may be vulnerable. The pollution should just be harmless data but this can cause problems for applications not expecting these properties to exist and can result in strange behavior or application crashes, i.e. a potential DOS vector. If your website or application does not render user provided data it should be unaffected. Versions 9.18.2 and 10.1.2 and newer include fixes for this vulnerability. If you are using version 7 or 8 you are encouraged to upgrade to a newer release.</Description>
    <URL>https://github.com/highlightjs/highlight.js/commit/7241013ae011a585983e176ddc0489a7a52f6bb0</URL>
    <CWE CWE="471">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" Consequence="Wrong Access Object" />
    </CWE>
    <Failure Comment="via Application Crash">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-26240" CVSS="7.5">
    <Description>Go Ethereum, or "Geth", is the official Golang implementation of the Ethereum protocol. An ethash mining DAG generation flaw in Geth before version 1.9.24 could cause miners to erroneously calculate PoW in an upcoming epoch (estimated early January, 2021). This happened on the ETC chain on 2020-11-06. This issue is relevant only for miners, non-mining nodes are unaffected. This issue is fixed as of 1.9.24</Description>
    <URL>https://github.com/ethereum/go-ethereum/commit/d990df909d7839640143344e79356754384dcdd0</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-26245" CVSS="9.8">
    <Description>npm package systeminformation before version 4.30.5 is vulnerable to Prototype Pollution leading to Command Injection. The issue was fixed with a rewrite of shell sanitations to avoid prototyper pollution problems. The issue is fixed in version 4.30.5. If you cannot upgrade, be sure to check or sanitize service parameter strings that are passed to si.inetChecksite().</Description>
    <URL>https://github.com/sebhildebrandt/systeminformation/commit/8113ff0e87b2f422a5756c48f1057575e73af016</URL>
    <CWE CWE="78">
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Command Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Command Injection" />
    </CWE>
    <CWE CWE="471">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" Consequence="Wrong Access Object" />
    </CWE>
    <Failure Comment="via Command Injection">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-26262" CVSS="7.2">
    <Description>Coturn is free open source implementation of TURN and STUN Server. Coturn before version 4.5.2 by default does not allow peers to connect and relay packets to loopback addresses in the range of `127.x.x.x`. However, it was observed that when sending a `CONNECT` request with the `XOR-PEER-ADDRESS` value of `0.0.0.0`, a successful response was received and subsequently, `CONNECTIONBIND` also received a successful response. Coturn then is able to relay packets to the loopback interface. Additionally, when coturn is listening on IPv6, which is default, the loopback interface can also be reached by making use of either `[::1]` or `[::]` as the peer address. By using the address `0.0.0.0` as the peer address, a malicious user will be able to relay packets to the loopback interface, unless `--denied-peer-ip=0.0.0.0` (or similar) has been specified. Since the default configuration implies that loopback peers are not allowed, coturn administrators may choose to not set the `denied-peer-ip` setting. The issue patched in version 4.5.2. As a workaround the addresses in the address block `0.0.0.0/8`, `[::1]` and `[::]` should be denied by default unless `--allow-loopback-peers` has been specified.</Description>
    <URL>https://github.com/coturn/coturn/commit/abfe1fd08d78baa0947d17dac0f7411c3d948e4d</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-26268" CVSS="4.4">
    <Description>In affected versions of TensorFlow the tf.raw_ops.ImmutableConst operation returns a constant tensor created from a memory mapped file which is assumed immutable. However, if the type of the tensor is not an integral type, the operation crashes the Python interpreter as it tries to write to the memory area. If the file is too small, TensorFlow properly returns an error as the memory area has fewer bytes than what is needed for the tensor it creates. However, as soon as there are enough bytes, the above snippet causes a segmentation fault. This is because the allocator used to return the buffer data is not marked as returning an opaque handle since the needed virtual method is not overridden. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/c1e1fc899ad5f8c725dcbb6470069890b5060bc7</URL>
    <CWE CWE="471">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" Consequence="Wrong Access Object" />
    </CWE>
    <Failure>Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-27194" CVSS="5.5">
    <Description>An issue was discovered in the Linux kernel before 5.8.15. scalar32_min_max_or in kernel/bpf/verifier.c mishandles bounds tracking during use of 64-bit values, aka CID-5b9fbeb75b6a.</Description>
    <URL>https://github.com/torvalds/linux/commit/5b9fbeb75b6a98955f628e205ac26689bcb1383e</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-27560" CVSS="3.3">
    <Description>ImageMagick 7.0.10-34 allows Division by Zero in OptimizeLayerFrames in MagickCore/layer.c, which may cause a denial of service.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/ef59bd764f88d893f1219fee8ba696a5d3f8c1c4</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-27764" CVSS="3.3">
    <Description>In /MagickCore/statistic.c, there are several areas in ApplyEvaluateOperator() where a size_t cast should have been a ssize_t cast, which causes out-of-range values under some circumstances when a crafted input file is processed by ImageMagick. Red Hat Product Security marked this as Low severity because although it could potentially lead to an impact to application availability, no specific impact was shown in this case. This flaw affects ImageMagick versions prior to 6.9.10-69.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick6/commit/3e21bc8a58b4ae38d24c7e283837cc279f35b6a5</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-27790" CVSS="5.5">
    <Description>A floating point exception issue was discovered in UPX in PackLinuxElf64::invert_pt_dynamic() function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger this issue that could cause a crash leading to a denial of service. The highest impact is to Availability.</Description>
    <URL>https://github.com/upx/upx/commit/eb90eab6325d009004ffb155e3e33f22d4d3ca26</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-27793" CVSS="7.5">
    <Description>An off-by-one overflow flaw was found in radare2 due to mismatched array length in core_java.c. This could allow an attacker to cause a crash, and perform a denail of service attack.</Description>
    <URL>https://github.com/radareorg/radare2/commit/ced0223c7a1b3b5344af315715cd28fe7c0d9ebc</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-28030" CVSS="7.5">
    <Description>In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.</Description>
    <URL>https://gitlab.com/wireshark/wireshark/-/commit/b287e7165e8aa89cde6ae37e7c257c5d87d16b9b</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="770">
      <MainWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Memory Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-28194" CVSS="9.8">
    <Description>Variable underflow exists in accel-ppp radius/packet.c when receiving a RADIUS vendor-specific attribute with length field is less than 2. It has an impact only when the attacker controls the RADIUS server, which can lead to arbitrary code execution.</Description>
    <URL>https://github.com/accel-ppp/accel-ppp/commit/e9d369aa0054312b7633e964e9f7eb323f1f3d69</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-28248" CVSS="8.8">
    <Description>An integer overflow in the PngImg::InitStorage_() function of png-img before 3.1.0 leads to an under-allocation of heap memory and subsequently an exploitable heap-based buffer overflow when loading a crafted PNG file.</Description>
    <URL>https://github.com/gemini-testing/png-img/commit/14ac462a32ca4b3b78f56502ac976d5b0222ce3d</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-28371" CVSS="9.8">
    <Description>An issue was discovered in ReadyTalk Avian 1.2.0 before 2020-10-27. The FileOutputStream.write() method in FileOutputStream.java has a boundary check to prevent out-of-bounds memory read/write operations. However, an integer overflow leads to bypassing this check and achieving the out-of-bounds access. NOTE: This vulnerability only affects products that are no longer supported by the maintainer</Description>
    <URL>https://github.com/ReadyTalk/avian/commit/0871979b298add320ca63f65060acb7532c8a0dd</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-35457" CVSS="7.8">
    <Description>GNOME GLib before 2.65.3 has an integer overflow, that might lead to an out-of-bounds write, in g_option_group_add_entries. NOTE: the vendor's position is "Realistically this is not a security issue. The standard pattern is for callers to provide a static list of option entries in a fixed number of calls to g_option_group_add_entries()." The researcher states that this pattern is undocumented</Description>
    <URL>https://gitlab.gnome.org/GNOME/glib/-/commit/63c5b62f0a984fac9a9700b12f54fe878e016a5d</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure>Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-35523" CVSS="7.8">
    <Description>An integer overflow flaw was found in libtiff that exists in the tif_getimage.c file. This flaw allows an attacker to inject and execute arbitrary code when a user opens a crafted TIFF file. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.</Description>
    <URL>https://gitlab.com/libtiff/libtiff/-/commit/c8d613ef497058fe653c467fc84c70a62a4a71b2</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-36221" CVSS="7.5">
    <Description>An integer underflow was discovered in OpenLDAP before 2.4.57 leading to slapd crashes in the Certificate Exact Assertion processing, resulting in denial of service (schema_init.c serialNumberAndIssuerCheck).</Description>
    <URL>https://git.openldap.org/openldap/openldap/-/commit/38ac838e4150c626bbfa0082b7e2cf3a2bb4df31</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-36228" CVSS="7.5">
    <Description>An integer underflow was discovered in OpenLDAP before 2.4.57 leading to a slapd crash in the Certificate List Exact Assertion processing, resulting in denial of service.</Description>
    <URL>https://git.openldap.org/openldap/openldap/-/commit/91dccd25c347733b365adc74cb07d074512ed5ad</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2020-4030" CVSS="6.5">
    <Description>In FreeRDP before version 2.1.2, there is an out of bounds read in TrioParse. Logging might bypass string length checks due to an integer overflow. This is fixed in version 2.1.2.</Description>
    <URL>https://github.com/FreeRDP/FreeRDP/commit/05cd9ea2290d23931f615c1b004d4b2e69074e27</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-4032" CVSS="4.3">
    <Description>In FreeRDP before version 2.1.2, there is an integer casting vulnerability in update_recv_secondary_order. All clients with +glyph-cache /relax-order-checks are affected. This is fixed in version 2.1.2.</Description>
    <URL>https://github.com/FreeRDP/FreeRDP/commit/e7bffa64ef5ed70bac94f823e2b95262642f5296</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2020-5310" CVSS="8.8">
    <Description>libImaging/TiffDecode.c in Pillow before 6.2.2 has a TIFF decoding integer overflow, related to realloc.</Description>
    <URL>https://github.com/python-pillow/Pillow/commit/4e2def2539ec13e53a82e06c4b3daf00454100c4</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-20224" CVSS="5.5">
    <Description>An integer overflow issue was discovered in ImageMagick's ExportIndexQuantum() function in MagickCore/quantum-export.c. Function calls to GetPixelIndex() could result in values outside the range of representable for the 'unsigned char'. When ImageMagick processes a crafted pdf file, this could lead to an undefined behaviour or a crash.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/5af1dffa4b6ab984b5f13d1e91c95760d75f12a6</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-20304" CVSS="7.5">
    <Description>A flaw was found in OpenEXR's hufDecode functionality. This flaw allows an attacker who can pass a crafted file to be processed by OpenEXR, to trigger an undefined right shift error. The highest threat from this vulnerability is to system availability.</Description>
    <URL>https://github.com/AcademySoftwareFoundation/openexr/commit/51a92d67f53c08230734e74564c807043cbfe41e</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-21253" CVSS="5.3">
    <Description>OnlineVotingSystem is an open source project hosted on GitHub. OnlineVotingSystem before version 1.1.2 hashes user passwords without a salt, which is vulnerable to dictionary attacks. Therefore there is a threat of security breach in the voting system. Without a salt, it is much easier for attackers to pre-compute the hash value using dictionary attack techniques such as rainbow tables to crack passwords. This problem is fixed and published in version 1.1.2. A long randomly generated salt is added to the password hash function to better protect passwords stored in the voting system.</Description>
    <URL>https://github.com/dbijaya/OnlineVotingSystem/commit/0181cb0272857696c8eb3e44fcf6cb014ff90f09</URL>
    <CWE CWE="759">
      <MainWeakness Cause="Erroneous Code" Operation="Define" Consequence="Wrong Access Function" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-21309" CVSS="8.8">
    <Description>Redis is an open-source, in-memory database that persists on disk. In affected versions of Redis an integer overflow bug in 32-bit Redis version 4.0 or newer could be exploited to corrupt the heap and potentially result with remote code execution. Redis 4.0 or newer uses a configurable limit for the maximum supported bulk input size. By default, it is 512MB which is a safe value for all platforms. If the limit is significantly increased, receiving a large request from a client may trigger several integer overflow scenarios, which would result with buffer overflow and heap corruption. We believe this could in certain conditions be exploited for remote code execution. By default, authenticated Redis users have access to all configuration parameters and can therefore use the “CONFIG SET proto-max-bulk-len” to change the safe default, making the system vulnerable. **This problem only affects 32-bit Redis (on a 32-bit system, or as a 32-bit executable running on a 64-bit system).** The problem is fixed in version 6.2, and the fix is back ported to 6.0.11 and 5.0.11. Make sure you use one of these versions if you are running 32-bit Redis. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent clients from directly executing `CONFIG SET`: Using Redis 6.0 or newer, ACL configuration can be used to block the command. Using older versions, the `rename-command` configuration directive can be used to rename the command to a random string unknown to users, rendering it inaccessible. Please note that this workaround may have an additional impact on users or operational systems that expect `CONFIG SET` to behave in certain ways.</Description>
    <URL>https://github.com/redis/redis/commit/c992857618db99776917f10bf4f2345a5fdc78b0</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-24025" CVSS="9.8">
    <Description>Due to incorrect string size calculations inside the preg_quote function, a large input string passed to the function can trigger an integer overflow leading to a heap overflow. This issue affects HHVM versions prior to 4.56.3, all versions between 4.57.0 and 4.80.1, all versions between 4.81.0 and 4.93.1, and versions 4.94.0, 4.95.0, 4.96.0, 4.97.0, 4.98.0.</Description>
    <URL>https://github.com/facebook/hhvm/commit/08193b7f0cd3910256e00d599f0f3eb2519c44ca</URL>
    <CWE CWE="122">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-24036" CVSS="9.8">
    <Description>Passing an attacker controlled size when creating an IOBuf could cause integer overflow, leading to an out of bounds write on the heap with the possibility of remote code execution. This issue affects versions of folly prior to v2021.07.22.00. This issue affects HHVM versions prior to 4.80.5, all versions between 4.81.0 and 4.102.1, all versions between 4.103.0 and 4.113.0, and versions 4.114.0, 4.115.0, 4.116.0, 4.117.0, 4.118.0 and 4.118.1.</Description>
    <URL>https://github.com/facebook/folly/commit/4f304af1411e68851bdd00ef6140e9de4616f7d3</URL>
    <CWE CWE="122">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-25803" CVSS="7.1">
    <Description>A buffer overflow vulnerability in the vlc_input_attachment_New component of VideoLAN VLC Media Player 3.0.11 allows attackers to cause an out-of-bounds read via a crafted .avi file.</Description>
    <URL>https://code.videolan.org/videolan/vlc-3.0/-/commit/56cbe9c4b59edbdc5e1bb2687992f3bbf492eccb</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-28856" CVSS="5.5">
    <Description>In Deark before v1.5.8, a specially crafted input file can cause a division by zero in (src/fmtutil.c) because of the value of pixelsize.</Description>
    <URL>https://github.com/jsummers/deark/commit/62acb7753b0e3c0d3ab3c15057b0a65222313334</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29279" CVSS="7.8">
    <Description>There is a integer overflow in function filter_core/filter_props.c:gf_props_assign_value in GPAC 1.0.1. In which, the arg const GF_PropertyValue *value,maybe value-&gt;value.data.size is a negative number. In result, memcpy in gf_props_assign_value failed.</Description>
    <URL>https://github.com/gpac/gpac/commit/da69ad1f970a7e17c865eaec9af98cc84df10d5b</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29517" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. A malicious user could trigger a division by 0 in `Conv3D` implementation. The implementation(https://github.com/tensorflow/tensorflow/blob/42033603003965bffac51ae171b51801565e002d/tensorflow/core/kernels/conv_ops_3d.cc#L143-L145) does a modulo operation based on user controlled input. Thus, when `filter` has a 0 as the fifth element, this results in a division by 0. Additionally, if the shape of the two tensors is not valid, an Eigen assertion can be triggered, resulting in a program crash. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/799f835a3dfa00a4d852defa29b15841eea9d64f</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29521" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. Specifying a negative dense shape in `tf.raw_ops.SparseCountSparseOutput` results in a segmentation fault being thrown out from the standard library as `std::vector` invariants are broken. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L199-L213) assumes the first element of the dense shape is always positive and uses it to initialize a `BatchedMap&lt;T&gt;` (i.e., `std::vector&lt;absl::flat_hash_map&lt;int64,T&gt;&gt;`(https://github.com/tensorflow/tensorflow/blob/8f7b60ee8c0206a2c99802e3a4d1bb55d2bc0624/tensorflow/core/kernels/count_ops.cc#L27)) data structure. If the `shape` tensor has more than one element, `num_batches` is the first value in `shape`. Ensuring that the `dense_shape` argument is a valid tensor shape (that is, all elements are non-negative) solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/c57c0b9f3a4f8684f3489dd9a9ec627ad8b599f5</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29522" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The `tf.raw_ops.Conv3DBackprop*` operations fail to validate that the input tensors are not empty. In turn, this would result in a division by 0. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a91bb59769f19146d5a0c20060244378e878f140/tensorflow/core/kernels/conv_grad_ops_3d.cc#L430-L450) does not check that the divisor used in computing the shard size is not zero. Thus, if attacker controls the input sizes, they can trigger a denial of service via a division by zero error. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/311403edbc9816df80274bd1ea8b3c0c0f22c3fa</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29523" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.AddManySparseToTensorsMap`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/kernels/sparse_tensors_map_ops.cc#L257) takes the values specified in `sparse_shape` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/69c68ecbb24dff3fa0e46da0d16c821a2dd22d7c</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29524" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/496c2630e51c1a478f095b084329acedb253db6b/tensorflow/core/kernels/conv_grad_shape_utils.cc#L130) does a modulus operation where the divisor is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/fca9874a9b42a2134f907d2fb46ab774a831404a</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29525" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b40060c9f697b044e3107917c797ba052f4506ab/tensorflow/core/kernels/conv_grad_input_ops.h#L625-L655) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/2be2cdf3a123e231b16f766aa0e27d56b4606535</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29526" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/988087bd83f144af14087fe4fecee2d250d93737/tensorflow/core/kernels/conv_ops.cc#L261-L263) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/b12aa1d44352de21d1a6faaf04172d8c2508b42b</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29527" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.QuantizedConv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/00e9a4d67d76703fa1aee33dac582acf317e0e81/tensorflow/core/kernels/quantized_conv_ops.cc#L257-L259) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/cfa91be9863a91d5105a3b4941096044ab32036b</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29528" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.QuantizedMul`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55900e961ed4a23b438392024912154a2c2f5e85/tensorflow/core/kernels/quantized_mul_op.cc#L188-L198) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/a1b11d2fdd1e51bfe18bb1ede804f60abfa92da6</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29529" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in `tf.raw_ops.QuantizedResizeBilinear` by manipulating input values so that float rounding results in off-by-one error in accessing image elements. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L62-L66) computes two integers (representing the upper and lower bounds for interpolation) by ceiling and flooring a floating point value. For some values of `in`, `interpolation-&gt;upper[i]` might be smaller than `interpolation-&gt;lower[i]`. This is an issue if `interpolation-&gt;upper[i]` is capped at `in_size-1` as it means that `interpolation-&gt;lower[i]` points outside of the image. Then, in the interpolation code(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L245-L264), this would result in heap buffer overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/f851613f8f0fb0c838d160ced13c134f778e3ce7</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29535" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedMul` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/87cf4d3ea9949051e50ca3f071fc909538a51cd0/tensorflow/core/kernels/quantized_mul_op.cc#L287-L290) assumes that the 4 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat&lt;T&gt;()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/efea03b38fb8d3b81762237dc85e579cc5fc6e87</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29536" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedReshape` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a324ac84e573fba362a5e53d4e74d5de6729933e/tensorflow/core/kernels/quantized_reshape_op.cc#L38-L55) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat&lt;T&gt;()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/a324ac84e573fba362a5e53d4e74d5de6729933e</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29537" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedResizeBilinear` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/50711818d2e61ccce012591eeb4fdf93a8496726/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L705-L706) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/f6c40f0c6cbf00d46c7717a26419f2062f2f8694</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29538" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a division by zero to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L513-L522) computes a divisor based on user provided data (i.e., the shape of the tensors given as arguments). If all shapes are empty then `work_unit_size` is 0. Since there is no check for this case before division, this results in a runtime exception, with potential to be abused for a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/c570e2ecfc822941335ad48f6e10df4e21f11c96</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29539" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.ImmutableConst`(https://www.tensorflow.org/api_docs/python/tf/raw_ops/ImmutableConst) with a `dtype` of `tf.resource` or `tf.variant` results in a segfault in the implementation as code assumes that the tensor contents are pure scalars. We have patched the issue in 4f663d4b8f0bec1b48da6fa091a7d29609980fa4 and will release TensorFlow 2.5.0 containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved. If using `tf.raw_ops.ImmutableConst` in code, you can prevent the segfault by inserting a filter for the `dtype` argument.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/4f663d4b8f0bec1b48da6fa091a7d29609980fa4</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29542" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow by passing crafted inputs to `tf.raw_ops.StringNGrams`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1cdd4da14282210cc759e468d9781741ac7d01bf/tensorflow/core/kernels/string_ngrams_op.cc#L171-L185) fails to consider corner cases where input would be split in such a way that the generated tokens should only contain padding elements. If input is such that `num_tokens` is 0, then, for `data_start_index=0` (when left padding is present), the marked line would result in reading `data[-1]`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/ba424dd8f16f7110eea526a8086f1a155f14f22b</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29545" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in converting sparse tensors to CSR Sparse matrices. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/800346f2c03a27e182dd4fba48295f65e7790739/tensorflow/core/kernels/sparse/kernels.cc#L66) does a double redirection to access an element of an array allocated on the heap. If the value at `indices(i, 0)` is such that `indices(i, 0) + 1` is outside the bounds of `csr_row_ptr`, this results in writing outside of bounds of heap allocated data. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/1e922ccdf6bf46a3a52641f99fd47d54c1decd13</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29546" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger an integer division by zero undefined behavior in `tf.raw_ops.QuantizedBiasAdd`. This is because the implementation of the Eigen kernel(https://github.com/tensorflow/tensorflow/blob/61bca8bd5ba8a68b2d97435ddfafcdf2b85672cd/tensorflow/core/kernels/quantization_utils.h#L812-L849) does a division by the number of elements of the smaller input (based on shape) without checking that this is not zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/67784700869470d65d5f2ef20aeb5e97c31673cb</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29548" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc) does not validate all constraints specified in the op's contract(https://www.tensorflow.org/api_docs/python/tf/raw_ops/QuantizedBatchNormWithGlobalNormalization). The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/d6ed5bcfe1dcab9e85a4d39931bd18d99018e75b</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29549" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L289-L295) computes a modulo operation without validating that the divisor is not zero. Since `vector_num_elements` is determined based on input shapes(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L522-L544), a user can trigger scenarios where this quantity is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/744009c9e5cc5d0447f0dc39d055f917e1fd9e16</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29550" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.FractionalAvgPool`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L85-L89) computes a divisor quantity by dividing two user controlled values. The user controls the values of `input_size[i]` and `pooling_ratio_[i]` (via the `value.shape()` and `pooling_ratio` arguments). If the value in `input_size[i]` is smaller than the `pooling_ratio_[i]`, then the floor operation results in `output_size[i]` being 0. The `DCHECK_GT` line is a no-op outside of debug mode, so in released versions of TF this does not trigger. Later, these computed values are used as arguments(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L96-L99) to `GeneratePoolingSequence`(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_pool_common.cc#L100-L108). There, the first computation is a division in a modulo operation. Since `output_length` can be 0, this results in runtime crashing. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/548b5eaf23685d86f722233d8fbc21d0a4aecb96</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29554" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.DenseCountSparseOutput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/efff014f3b2d8ef6141da30c806faf141297eca1/tensorflow/core/kernels/count_ops.cc#L123-L127) computes a divisor value from user data but does not check that the result is 0 before doing the division. Since `data` is given by the `values` argument, `num_batch_elements` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, and TensorFlow 2.3.3, as these are also affected.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/da5ff2daf618591f64b2b62d9d9803951b945e9f</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29555" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.FusedBatchNorm`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/828f346274841fa7505f7020e88ca36c22e557ab/tensorflow/core/kernels/fused_batch_norm_op.cc#L295-L297) performs a division based on the last dimension of the `x` tensor. Since this is controlled by the user, an attacker can trigger a denial of service. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/1a2a87229d1d61e23a39373777c056161eb4084d</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29556" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.Reverse`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/36229ea9e9451dac14a8b1f4711c435a1d84a594/tensorflow/core/kernels/reverse_op.cc#L75-L76) performs a division based on the first dimension of the tensor argument. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/4071d8e2f6c45c1955a811fee757ca2adbe462c1</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29557" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via a FPE runtime error in `tf.raw_ops.SparseMatMul`. The division by 0 occurs deep in Eigen code because the `b` tensor is empty. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/7f283ff806b2031f407db64c4d3edcda8fb9f9f5</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29573" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` is vulnerable to a division by 0. The implementation(https://github.com/tensorflow/tensorflow/blob/279bab6efa22752a2827621b7edb56a730233bd8/tensorflow/core/kernels/maxpooling_op.cc#L1033-L1034) fails to validate that the batch dimension of the tensor is non-zero, before dividing by this quantity. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/376c352a37ce5a68b721406dc7e77ac4b6cf483d</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29584" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in caused by an integer overflow in constructing a new tensor shape. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/0908c2f2397c099338b901b067f6495a5b96760b/tensorflow/core/kernels/sparse_split_op.cc#L66-L70) builds a dense shape without checking that the dimensions would not result in overflow. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/4c0ee937c0f61c4fc5f5d32d9bb4c67428012a60</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29585" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The TFLite computation for size of output after padding, `ComputeOutSize`(https://github.com/tensorflow/tensorflow/blob/0c9692ae7b1671c983569e5d3de5565843d500cf/tensorflow/lite/kernels/padding.h#L43-L55), does not check that the `stride` argument is not 0 before doing the division. Users can craft special models such that `ComputeOutSize` is called with `stride` set to 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/49847ae69a4e1a97ae7f2db5e217c77721e37948</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29586" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. Optimized pooling implementations in TFLite fail to check that the stride arguments are not 0 before calling `ComputePaddingHeightWidth`(https://github.com/tensorflow/tensorflow/blob/3f24ccd932546416ec906a02ddd183b48a1d2c83/tensorflow/lite/kernels/pooling.cc#L90). Since users can craft special models which will have `params-&gt;stride_{height,width}` be zero, this will result in a division by zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/5f7975d09eac0f10ed8a17dbb6f5964977725adc</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29587" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The `Prepare` step of the `SpaceToDepth` TFLite operator does not check for 0 before division(https://github.com/tensorflow/tensorflow/blob/5f7975d09eac0f10ed8a17dbb6f5964977725adc/tensorflow/lite/kernels/space_to_depth.cc#L63-L67). An attacker can craft a model such that `params-&gt;block_size` would be zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29588" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The optimized implementation of the `TransposeConv` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L5221-L5222). An attacker can craft a model such that `stride_{h,w}` values are 0. Code calling this function must validate these arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/801c1c6be5324219689c98e1bd3e0ca365ee834d</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29589" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The reference implementation of the `GatherNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/reference/reference_ops.h#L966). An attacker can craft a model such that `params` input would be an empty tensor. In turn, `params_shape.Dims(.)` would be zero, in at least one dimension. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/8e45822aa0b9f5df4b4c64f221e64dc930a70a9d</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29593" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `BatchToSpaceNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/b5ed552fe55895aee8bd8b191f744a069957d18d/tensorflow/lite/kernels/batch_to_space_nd.cc#L81-L82). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/2c74674348a4708ced58ad6eb1b23354df8ee044</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29594" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. TFLite's convolution code(https://github.com/tensorflow/tensorflow/blob/09c73bca7d648e961dd05898292d91a8322a9d45/tensorflow/lite/kernels/conv.cc) has multiple division where the divisor is controlled by the user and not checked to be non-zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/ff489d95a9006be080ad14feb378f2b4dac35552</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29595" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthToSpace` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/depth_to_space.cc#L63-L69). An attacker can craft a model such that `params-&gt;block_size` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/106d8f4fb89335a2c52d7c895b7a7485465ca8d9</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29596" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `EmbeddingLookup` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e4b29809543b250bc9b19678ec4776299dd569ba/tensorflow/lite/kernels/embedding_lookup.cc#L73-L74). An attacker can craft a model such that the first dimension of the `value` input is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/f61c57bd425878be108ec787f4d96390579fb83e</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29597" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SpaceToBatchNd` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/412c7d9bb8f8a762c5b266c9e73bfa165f29aac8/tensorflow/lite/kernels/space_to_batch_nd.cc#L82-L83). An attacker can craft a model such that one dimension of the `block` input is 0. Hence, the corresponding value in `block_shape` is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/6d36ba65577006affb272335b7c1abd829010708</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29598" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `SVDF` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/7f283ff806b2031f407db64c4d3edcda8fb9f9f5/tensorflow/lite/kernels/svdf.cc#L99-L102). An attacker can craft a model such that `params-&gt;rank` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/6841e522a3e7d48706a02e8819836e809f738682</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29599" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `Split` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e2752089ef7ce9bcf3db0ec618ebd23ea119d0c7/tensorflow/lite/kernels/split.cc#L63-L65). An attacker can craft a model such that `num_splits` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/b22786e7e9b7bdb6a56936ff29cc7e9968d7bc1d</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29600" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `OneHot` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/f61c57bd425878be108ec787f4d96390579fb83e/tensorflow/lite/kernels/one_hot.cc#L68-L72). An attacker can craft a model such that at least one of the dimensions of `indices` would be 0. In turn, the `prefix_dim_size` value would become 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/3ebedd7e345453d68e279cfc3e4072648e5e12e5</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29601" CVSS="7.1">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of concatenation is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/7b7352a724b690b11bfaae2cd54bc3907daf6285/tensorflow/lite/kernels/concatenation.cc#L70-L76). An attacker can craft a model such that the dimensions of one of the concatenation input overflow the values of `int`. TFLite uses `int` to represent tensor dimensions, whereas TF uses `int64`. Hence, valid TF models can trigger an integer overflow when converted to TFLite format. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/4253f96a58486ffe84b61c0415bb234a4632ee73</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29602" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `DepthwiseConv` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/depthwise_conv.cc#L287-L288). An attacker can craft a model such that `input`'s fourth dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/cbda3c6b2dbbd3fbdc482ff8c0170a78ec2e97d0</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29604" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of hashtable lookup is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/1a8e885b864c818198a5b2c0cbbeca5a1e833bc8/tensorflow/lite/kernels/hashtable_lookup.cc#L114-L115) An attacker can craft a model such that `values`'s first dimension would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/5117e0851348065ed59c991562c0ec80d9193db2</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-29605" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. The TFLite code for allocating `TFLiteIntArray`s is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L24-L27). An attacker can craft a model such that the `size` multiplier is so large that the return value overflows the `int` datatype and becomes negative. In turn, this results in invalid value being given to `malloc`(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L47-L52). In this case, `ret-&gt;size` would dereference an invalid pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-29608" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.RaggedTensorToTensor`, an attacker can exploit an undefined behavior if input arguments are empty. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L356-L360) only checks that one of the tensors is not empty, but does not check for the other ones. There are multiple `DCHECK` validations to prevent heap OOB, but these are no-op in release builds, hence they don't prevent anything. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/b761c9b652af2107cfbc33efd19be0ce41daa33e</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-30014" CVSS="5.5">
    <Description>There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.</Description>
    <URL>https://github.com/gpac/gpac/commit/51cdb67ff7c5f1242ac58c5aa603ceaf1793b788</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-30022" CVSS="5.5">
    <Description>There is a integer overflow in media_tools/av_parsers.c in the gf_avc_read_pps_bs_internal in GPAC 1.0.1. pps_id may be a negative number, so it will not return. However, avc-&gt;pps only has 255 unit, so there is an overflow, which results a crash.</Description>
    <URL>https://github.com/gpac/gpac/commit/51cdb67ff7c5f1242ac58c5aa603ceaf1793b788</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-3114" CVSS="6.5">
    <Description>In Go before 1.14.14 and 1.15.x before 1.15.7, crypto/elliptic/p224.go can generate incorrect outputs, related to an underflow of the lowest limb during the final complete reduction in the P-224 field.</Description>
    <URL>https://github.com/golang/go/commit/d95ca9138026cbe40e0857d76a81a16d03230871</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-31440" CVSS="7.0">
    <Description>This vulnerability allows local attackers to escalate privileges on affected installations of Linux Kernel 5.11.15. An attacker must first obtain the ability to execute low-privileged code on the target system in order to exploit this vulnerability. The specific flaw exists within the handling of eBPF programs. The issue results from the lack of proper validation of user-supplied eBPF programs prior to executing them. An attacker can leverage this vulnerability to escalate privileges and execute arbitrary code in the context of the kernel. Was ZDI-CAN-13661.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=10bf4e83167cc68595b85fd73bb91e8f2c086e36</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-31571" CVSS="9.8">
    <Description>The kernel in Amazon Web Services FreeRTOS before 10.4.3 has an integer overflow in queue.c for queue creation.</Description>
    <URL>https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/47338393f1f79558f6144213409f09f81d7c4837</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-31572" CVSS="9.8">
    <Description>The kernel in Amazon Web Services FreeRTOS before 10.4.3 has an integer overflow in stream_buffer.c for a stream buffer.</Description>
    <URL>https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/d05b9c123f2bf9090bce386a244fc934ae44db5b</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-31870" CVSS="9.8">
    <Description>An issue was discovered in klibc before 2.0.9. Multiplication in the calloc() function may result in an integer overflow and a subsequent heap buffer overflow.</Description>
    <URL>https://git.kernel.org/pub/scm/libs/klibc/klibc.git/commit/?id=292650f04c2b5348b4efbad61fb014ed09b4f3f2</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-31871" CVSS="7.5">
    <Description>An issue was discovered in klibc before 2.0.9. An integer overflow in the cpio command may result in a NULL pointer dereference on 64-bit systems.</Description>
    <URL>https://git.kernel.org/pub/scm/libs/klibc/klibc.git/commit/?id=2e48a12ab1e30d43498c2d53e878a11a1b5102d5</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-31872" CVSS="9.8">
    <Description>An issue was discovered in klibc before 2.0.9. Multiple possible integer overflows in the cpio command on 32-bit systems may result in a buffer overflow or other security impact.</Description>
    <URL>https://git.kernel.org/pub/scm/libs/klibc/klibc.git/commit/?id=9b1c91577aef7f2e72c3aa11a27749160bd278ff</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-31873" CVSS="9.8">
    <Description>An issue was discovered in klibc before 2.0.9. Additions in the malloc() function may result in an integer overflow and a subsequent heap buffer overflow.</Description>
    <URL>https://git.kernel.org/pub/scm/libs/klibc/klibc.git/commit/?id=a31ae8c508fc8d1bca4f57e9f9f88127572d5202</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-31933" CVSS="7.2">
    <Description>A remote code execution vulnerability exists in Chamilo through 1.11.14 due to improper input sanitization of a parameter used for file uploads, and improper file-extension filtering for certain filenames (e.g., .phar or .pht). A remote authenticated administrator is able to upload a file containing arbitrary PHP code into specific directories via main/inc/lib/fileUpload.lib.php directory traversal to achieve PHP code execution.</Description>
    <URL>https://github.com/chamilo/chamilo-lms/commit/229302139e8d23bf6862183cf219b967f6e2fbc1</URL>
    <CWE CWE="706">
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Object Resolved" />
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Function Resolved" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="Directory Traversal Injection">Data Tempering (TPR)</Failure>
    <Failure Comment="Directory Traversal Injection">Information Exposure (IEX)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-32054" CVSS="6.1">
    <Description>Firely/Incendi Spark before 1.5.5-r4 lacks Content-Disposition headers in certain situations, which may cause crafted files to be delivered to clients such that they are rendered directly in a victim's web browser.</Description>
    <URL>https://github.com/FirelyTeam/spark/commit/9c79320059f92d8aa4fbd6cc4fa8f9d5d6ba9941</URL>
    <CWE CWE="706">
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Object Resolved" />
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Function Resolved" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-32494" CVSS="7.5">
    <Description>Radare2 has a division by zero vulnerability in Mach-O parser's rebase_buffer function. This allow attackers to create malicious inputs that can cause denial of service.


</Description>
    <URL>https://github.com/radareorg/radare2/commit/a07dedb804a82bc01c07072861942dd80c6b6d62</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-32627" CVSS="7.5">
    <Description>Redis is an open source, in-memory database that persists on disk. In affected versions an integer overflow bug in Redis can be exploited to corrupt the heap and potentially result with remote code execution. The vulnerability involves changing the default proto-max-bulk-len and client-query-buffer-limit configuration parameters to very large values and constructing specially crafted very large stream elements. The problem is fixed in Redis 6.2.6, 6.0.16 and 5.0.14. For users unable to upgrade an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the proto-max-bulk-len configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.</Description>
    <URL>https://github.com/redis/redis/commit/f6a40570fa63d5afdd596c78083d754081d80ae3</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="680">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-32628" CVSS="7.5">
    <Description>Redis is an open source, in-memory database that persists on disk. An integer overflow bug in the ziplist data structure used by all versions of Redis can be exploited to corrupt the heap and potentially result with remote code execution. The vulnerability involves modifying the default ziplist configuration parameters (hash-max-ziplist-entries, hash-max-ziplist-value, zset-max-ziplist-entries or zset-max-ziplist-value) to a very large value, and then constructing specially crafted commands to create very large ziplists. The problem is fixed in Redis versions 6.2.6, 6.0.16, 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the above configuration parameters. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.</Description>
    <URL>https://github.com/redis/redis/commit/f6a40570fa63d5afdd596c78083d754081d80ae3</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="680">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-32629" CVSS="8.8">
    <Description>Cranelift is an open-source code generator maintained by Bytecode Alliance. It translates a target-independent intermediate representation into executable machine code. There is a bug in 0.73 of the Cranelift x64 backend that can create a scenario that could result in a potential sandbox escape in a Wasm program. This bug was introduced in the new backend on 2020-09-08 and first included in a release on 2020-09-30, but the new backend was not the default prior to 0.73. The recently-released version 0.73 with default settings, and prior versions with an explicit build flag to select the new backend, are vulnerable. The bug in question performs a sign-extend instead of a zero-extend on a value loaded from the stack, under a specific set of circumstances. If those circumstances occur, the bug could allow access to memory addresses upto 2GiB before the start of the Wasm program heap. If the heap bound is larger than 2GiB, then it would be possible to read memory from a computable range dependent on the size of the heaps bound. The impact of this bug is highly dependent on heap implementation, specifically: * if the heap has bounds checks, and * does not rely exclusively on guard pages, and * the heap bound is 2GiB or smaller * then this bug cannot be used to reach memory from another Wasm program heap. The impact of the vulnerability is mitigated if there is no memory mapped in the range accessible using this bug, for example, if there is a 2 GiB guard region before the Wasm program heap. The bug in question performs a sign-extend instead of a zero-extend on a value loaded from the stack, when the register allocator reloads a spilled integer value narrower than 64 bits. This interacts poorly with another optimization: the instruction selector elides a 32-to-64-bit zero-extend operator when we know that an instruction producing a 32-bit value actually zeros the upper 32 bits of its destination register. Hence, we rely on these zeroed bits, but the type of the value is still i32, and the spill/reload reconstitutes those bits as the sign extension of the i32’s MSB. The issue would thus occur when: * An i32 value in a Wasm program is greater than or equal to 0x8000_0000; * The value is spilled and reloaded by the register allocator due to high register pressure in the program between the value’s definition and its use; * The value is produced by an instruction that we know to be “special” in that it zeroes the upper 32 bits of its destination: add, sub, mul, and, or; * The value is then zero-extended to 64 bits in the Wasm program; * The resulting 64-bit value is used. Under these circumstances there is a potential sandbox escape when the i32 value is a pointer. The usual code emitted for heap accesses zero-extends the Wasm heap address, adds it to a 64-bit heap base, and accesses the resulting address. If the zero-extend becomes a sign-extend, the program could reach backward and access memory up to 2GiB before the start of its heap. In addition to assessing the nature of the code generation bug in Cranelift, we have also determined that under specific circumstances, both Lucet and Wasmtime using this version of Cranelift may be exploitable. See referenced GitHub Advisory for more details.</Description>
    <URL>https://github.com/bytecodealliance/wasmtime/commit/95559c01aaa7c061088a433040f31e8291fb09d0</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <CWE CWE="788">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-32687" CVSS="7.5">
    <Description>Redis is an open source, in-memory database that persists on disk. An integer overflow bug affecting all versions of Redis can be exploited to corrupt the heap and potentially be used to leak arbitrary contents of the heap or trigger remote code execution. The vulnerability involves changing the default set-max-intset-entries configuration parameter to a very large value and constructing specially crafted commands to manipulate sets. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the set-max-intset-entries configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.</Description>
    <URL>https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="680">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-32762" CVSS="8.8">
    <Description>Redis is an open source, in-memory database that persists on disk. The redis-cli command line tool and redis-sentinel service may be vulnerable to integer overflow when parsing specially crafted large multi-bulk network replies. This is a result of a vulnerability in the underlying hiredis library which does not perform an overflow check before calling the calloc() heap allocation function. This issue only impacts systems with heap allocators that do not perform their own overflow checks. Most modern systems do and are therefore not likely to be affected. Furthermore, by default redis-sentinel uses the jemalloc allocator which is also not vulnerable. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14.</Description>
    <URL>https://github.com/redis/redis/commit/0215324a66af949be39b34be2d55143232c1cb71</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="680">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-32765" CVSS="8.8">
    <Description>Hiredis is a minimalistic C client library for the Redis database. In affected versions Hiredis is vulnurable to integer overflow if provided maliciously crafted or corrupted `RESP` `mult-bulk` protocol data. When parsing `multi-bulk` (array-like) replies, hiredis fails to check if `count * sizeof(redisReply*)` can be represented in `SIZE_MAX`. If it can not, and the `calloc()` call doesn't itself make this check, it would result in a short allocation and subsequent buffer overflow. Users of hiredis who are unable to update may set the [maxelements](https://github.com/redis/hiredis#reader-max-array-elements) context option to a value small enough that no overflow is possible.</Description>
    <URL>https://github.com/redis/hiredis/commit/76a7b10005c70babee357a7d0f2becf28ec7ed1e</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="680">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-33631" CVSS="7.8">
    <Description>Integer Overflow or Wraparound vulnerability in openEuler kernel on Linux (filesystem modules) allows Forced Integer Overflow.This issue affects openEuler kernel: from 4.19.90 before 4.19.90-2401.3, from 5.10.0-60.18.0 before 5.10.0-183.0.0.

</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5c099c4fdc438014d5893629e70a8ba934433ee8</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-33797" CVSS="9.8">
    <Description>Buffer-overflow in jsdtoa.c in Artifex MuJS in versions 1.0.1 to 1.1.1. An integer overflow happens when js_strtod() reads in floating point exponent, which leads to a buffer overflow in the pointer *d.</Description>
    <URL>https://github.com/ccxvii/mujs/commit/833b6f1672b4f2991a63c4d05318f0b84ef4d550</URL>
    <CWE CWE="119">
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-33909" CVSS="7.8">
    <Description>fs/seq_file.c in the Linux kernel 3.16 through 5.13.x before 5.13.4 does not properly restrict seq buffer allocations, leading to an integer overflow, an Out-of-bounds Write, and escalation to root by an unprivileged user, aka CID-8cae8cd89f05.</Description>
    <URL>https://github.com/torvalds/linux/commit/8cae8cd89f05f6de223d63e6d15e31c8ba9cf53b</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure>Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-3444" CVSS="7.8">
    <Description>The bpf verifier in the Linux kernel did not properly handle mod32 destination register truncation when the source register was known to be 0. A local attacker with the ability to load bpf programs could use this gain out-of-bounds reads in kernel memory leading to information disclosure (kernel memory), and possibly out-of-bounds writes that could potentially lead to code execution. This issue was addressed in the upstream kernel in commit 9b00f1b78809 ("bpf: Fix truncation handling for mod32 dst reg wrt zero") and in Linux stable kernels 5.11.2, 5.10.19, and 5.4.101.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9b00f1b78809</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-3472" CVSS="7.8">
    <Description>A flaw was found in xorg-x11-server in versions before 1.20.11. An integer underflow can occur in xserver which can lead to a local privilege escalation. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.</Description>
    <URL>https://gitlab.freedesktop.org/xorg/xserver/-/commit/7aaf54a1884f71dc363f0b884e57bcb67407a6cd</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-3491" CVSS="8.8">
    <Description>The io_uring subsystem in the Linux kernel allowed the MAX_RW_COUNT limit to be bypassed in the PROVIDE_BUFFERS operation, which led to negative values being usedin mem_rw when reading /proc/&lt;PID&gt;/mem. This could be used to create a heap overflow leading to arbitrary code execution in the kernel. It was addressed via commit d1f82808877b ("io_uring: truncate lengths larger than MAX_RW_COUNT on provide buffers") (v5.13-rc1) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. It was introduced in ddf0322db79c ("io_uring: add IORING_OP_PROVIDE_BUFFERS") (v5.7-rc1).</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d1f82808877bb10d3deee7cf3374a4eb3fb582db</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-36357" CVSS="9.8">
    <Description>An issue was discovered in OpenPOWER 2.6 firmware. unpack_timestamp() calls le32_to_cpu() for endian conversion of a uint16_t "year" value, resulting in a type mismatch that can truncate a higher integer value to a smaller one, and bypass a timestamp check. The fix is to use the right endian conversion function.</Description>
    <URL>https://github.com/open-power/skiboot/commit/5be38b672c1410e2f10acd3ad2eecfdc81d5daf7</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-36692" CVSS="6.5">
    <Description>libjxl v0.3.7 is affected by a Divide By Zero in issue in lib/extras/codec_apng.cc jxl::DecodeImageAPNG(). When encoding a malicous APNG file using cjxl, an attacker can trigger a denial of service.</Description>
    <URL>https://github.com/libjxl/libjxl/commit/7dfa400ded53919d986c5d3d23446a09e0cf481b</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-37600" CVSS="5.5">
    <Description>An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments.</Description>
    <URL>https://github.com/karelzak/util-linux/commit/1c9143d0c1f979c3daf10e1c37b5b1e916c22a1c</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-37636" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseDenseCwiseDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L56) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit d9204be9f49520cdaaeb2541d1dc5187b23f31d9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/d9204be9f49520cdaaeb2541d1dc5187b23f31d9</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-37640" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseReshape` can be made to trigger an integral division by 0 exception. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L176-L181) calls the reshaping functor whenever there is at least an index in the input but does not check that shape of the input or the target shape have both a non-zero number of elements. The [reshape functor](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/reshape_util.cc#L40-L78) blindly divides by the dimensions of the target shape. Hence, if this is not checked, code will result in a division by 0. We have patched the issue in GitHub commit 4923de56ec94fff7770df259ab7f2288a74feb41. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1 as this is the other affected version.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/4923de56ec94fff7770df259ab7f2288a74feb41</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-37642" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.ResourceScatterDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/resource_variable_ops.cc#L865) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit 4aacb30888638da75023e6601149415b39763d76. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/4aacb30888638da75023e6601149415b39763d76</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-37645" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.QuantizeAndDequantizeV4Grad` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L126) uses the `axis` value as the size argument to `absl::InlinedVector` constructor. But, the constructor uses an unsigned type for the argument, so the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit 96f364a1ca3009f98980021c4b32be5fdcca33a1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, and TensorFlow 2.4.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/96f364a1ca3009f98980021c4b32be5fdcca33a1</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-37646" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.StringNGrams` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/string_ngrams_op.cc#L184) calls `reserve` on a `tstring` with a value that sometimes can be negative if user supplies negative `ngram_widths`. The `reserve` method calls `TF_TString_Reserve` which has an `unsigned long` argument for the size of the buffer. Hence, the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit c283e542a3f422420cfdb332414543b62fc4e4a5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/c283e542a3f422420cfdb332414543b62fc4e4a5</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-37653" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a floating point exception in `tf.raw_ops.ResourceGather`. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L725-L731) computes the value of a value, `batch_size`, and then divides by it without checking that this value is not 0. We have patched the issue in GitHub commit ac117ee8a8ea57b73d34665cdf00ef3303bc0b11. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/ac117ee8a8ea57b73d34665cdf00ef3303bc0b11</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-37660" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a floating point exception by calling inplace operations with crafted arguments that would result in a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/inplace_ops.cc#L283) has a logic error: it should skip processing if `x` and `v` are empty but the code uses `||` instead of `&amp;&amp;`. We have patched the issue in GitHub commit e86605c0a336c088b638da02135ea6f9f6753618. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/e86605c0a336c088b638da02135ea6f9f6753618</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-37661" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause a denial of service in `boosted_trees_create_quantile_stream_resource` by using negative arguments. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantile_ops.cc#L96) does not validate that `num_streams` only contains non-negative numbers. In turn, [this results in using this value to allocate memory](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/boosted_trees/quantiles/quantile_stream_resource.h#L31-L40). However, `reserve` receives an unsigned integer so there is an implicit conversion from a negative value to a large positive unsigned. This results in a crash from the standard library. We have patched the issue in GitHub commit 8a84f7a2b5a2b27ecf88d25bad9ac777cd2f7992. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/8a84f7a2b5a2b27ecf88d25bad9ac777cd2f7992</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-37668" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.UnravelIndex` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unravel_index_op.cc#L36) does not check that the tensor subsumed by `dims` is not empty. Hence, if one element of `dims` is 0, the implementation does a division by 0. We have patched the issue in GitHub commit a776040a5e7ebf76eeb7eb923bf1ae417dd4d233. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/a776040a5e7ebf76eeb7eb923bf1ae417dd4d233</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-37669" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.NonMaxSuppressionV5` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/image/non_max_suppression_op.cc#L170-L271) uses a user controlled argument to resize a `std::vector`. However, as `std::vector::resize` takes the size argument as a `size_t` and `output_size` is an `int`, there is an implicit conversion to unsigned. If the attacker supplies a negative value, this conversion results in a crash. A similar issue occurs in `CombinedNonMaxSuppression`. We have patched the issue in GitHub commit 3a7362750d5c372420aa8f0caf7bf5b5c3d0f52d and commit [b5cdbf12ffcaaffecf98f22a6be5a64bb96e4f58. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/3a7362750d5c372420aa8f0caf7bf5b5c3d0f52d</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-37675" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions most implementations of convolution operators in TensorFlow are affected by a division by 0 vulnerability where an attacker can trigger a denial of service via a crash. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/framework/common_shape_fns.cc#L577) is missing several validations before doing divisions and modulo operations. We have patched the issue in GitHub commit 8a793b5d7f59e37ac7f3cd0954a750a2fe76bad4. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/8a793b5d7f59e37ac7f3cd0954a750a2fe76bad4</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-37679" CVSS="7.8">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions it is possible to nest a `tf.map_fn` within another `tf.map_fn` call. However, if the input tensor is a `RaggedTensor` and there is no function signature provided, code assumes the output is a fully specified tensor and fills output buffer with uninitialized contents from the heap. The `t` and `z` outputs should be identical, however this is not the case. The last row of `t` contains data from the heap which can be used to leak other memory information. The bug lies in the conversion from a `Variant` tensor to a `RaggedTensor`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/ragged_tensor_from_variant_op.cc#L177-L190) does not check that all inner shapes match and this results in the additional dimensions. The same implementation can result in data loss, if input tensor is tweaked. We have patched the issue in GitHub commit 4e2565483d0ffcadc719bd44893fb7f609bb5f12. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/4e2565483d0ffcadc719bd44893fb7f609bb5f12</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-37680" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of fully connected layers in TFLite is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/fully_connected.cc#L226). We have patched the issue in GitHub commit 718721986aa137691ee23f03638867151f74935f. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/718721986aa137691ee23f03638867151f74935f</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-37683" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of division in TFLite is [vulnerable to a division by 0 error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/div.cc). There is no check that the divisor tensor does not contain zero elements. We have patched the issue in GitHub commit 1e206baedf8bef0334cca3eb92bab134ef525a28. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/1e206baedf8bef0334cca3eb92bab134ef525a28</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-37691" CVSS="5.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a division by zero error in LSH [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/lsh_projection.cc#L118). We have patched the issue in GitHub commit 0575b640091680cfb70f4dd93e70658de43b94f9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick thiscommit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/0575b640091680cfb70f4dd93e70658de43b94f9</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-37706" CVSS="9.8">
    <Description>PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In affected versions if the incoming STUN message contains an ERROR-CODE attribute, the header length is not checked before performing a subtraction operation, potentially resulting in an integer underflow scenario. This issue affects all users that use STUN. A malicious actor located within the victim’s network may forge and send a specially crafted UDP (STUN) message that could remotely execute arbitrary code on the victim’s machine. Users are advised to upgrade as soon as possible. There are no known workarounds.</Description>
    <URL>https://github.com/pjsip/pjproject/commit/15663e3f37091069b8c98a7fce680dc04bc8e865</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-3797" CVSS="9.8">
    <Description>hestiacp is vulnerable to Use of Wrong Operator in String Comparison</Description>
    <URL>https://github.com/hestiacp/hestiacp/commit/fc68baff4f94b59e38316f886d0ce47d337042f7</URL>
    <CWE CWE="597">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-38090" CVSS="8.8">
    <Description>Integer Overflow vulnerability in function filter16_roberts in libavfilter/vf_convolution.c in Ffmpeg 4.2.1, allows attackers to cause a Denial of Service or other unspecified impacts.</Description>
    <URL>https://git.ffmpeg.org/gitweb/ffmpeg.git/commit/99f8d32129dd233d4eb2efa44678a0bc44869f23</URL>
    <CWE CWE="120">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-38091" CVSS="8.8">
    <Description>Integer Overflow vulnerability in function filter16_sobel in libavfilter/vf_convolution.c in Ffmpeg 4.2.1, allows attackers to cause a Denial of Service or other unspecified impacts.</Description>
    <URL>https://git.ffmpeg.org/gitweb/ffmpeg.git/commit/99f8d32129dd233d4eb2efa44678a0bc44869f23</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-38092" CVSS="8.8">
    <Description>Integer Overflow vulnerability in function filter_prewitt in libavfilter/vf_convolution.c in Ffmpeg 4.2.1, allows attackers to cause a Denial of Service or other unspecified impacts.</Description>
    <URL>https://git.ffmpeg.org/gitweb/ffmpeg.git/commit/99f8d32129dd233d4eb2efa44678a0bc44869f23</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-38093" CVSS="8.8">
    <Description>Integer Overflow vulnerability in function filter_robert in libavfilter/vf_convolution.c in Ffmpeg 4.2.1, allows attackers to cause a Denial of Service or other unspecified impacts.</Description>
    <URL>https://git.ffmpeg.org/gitweb/ffmpeg.git/commit/99f8d32129dd233d4eb2efa44678a0bc44869f23</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-38094" CVSS="8.8">
    <Description>Integer Overflow vulnerability in function filter_sobel in libavfilter/vf_convolution.c in Ffmpeg 4.2.1, allows attackers to cause a Denial of Service or other unspecified impacts.</Description>
    <URL>https://git.ffmpeg.org/gitweb/ffmpeg.git/commit/99f8d32129dd233d4eb2efa44678a0bc44869f23</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-38166" CVSS="7.8">
    <Description>In kernel/bpf/hashtab.c in the Linux kernel through 5.13.8, there is an integer overflow and out-of-bounds write when many elements are placed in a single bucket. NOTE: exploitation might be impractical without the CAP_SYS_ADMIN capability.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=c4eb1f403243fc7bbb7de644db8587c03de36da6</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure>Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-38185" CVSS="7.8">
    <Description>GNU cpio through 2.13 allows attackers to execute arbitrary code via a crafted pattern file, because of a dstring.c ds_fgetstr integer overflow that triggers an out-of-bounds heap write. NOTE: it is unclear whether there are common cases where the pattern file, associated with the -E option, is untrusted data.</Description>
    <URL>https://git.savannah.gnu.org/cgit/cpio.git/commit/?id=dd96882877721703e19272fe25034560b794061b</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-3828" CVSS="7.5">
    <Description>nltk is vulnerable to Inefficient Regular Expression Complexity</Description>
    <URL>https://github.com/nltk/nltk/commit/277711ab1dec729e626b27aab6fa35ea5efbd7e6</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-40346" CVSS="7.5">
    <Description>An integer overflow exists in HAProxy 2.0 through 2.5 in htx_add_header that can be exploited to perform an HTTP request smuggling attack, allowing an attacker to bypass all configured http-request HAProxy ACLs and possibly other ACLs.</Description>
    <URL>https://github.com/haproxy/haproxy/commit/3b69886f7dcc3cfb3d166309018e6cfec9ce2c95</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-40562" CVSS="5.5">
    <Description>A Segmentation fault caused by a floating point exception exists in Gpac through 1.0.1 using mp4box via the naludmx_enqueue_or_dispatch function in reframe_nalu.c, which causes a denial of service.</Description>
    <URL>https://github.com/gpac/gpac/commit/5dd71c7201a3e5cf40732d585bfb21c906c171d3</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-4070" CVSS="9.1">
    <Description>Off-by-one Error in GitHub repository v2fly/v2ray-core prior to 4.44.0.</Description>
    <URL>https://github.com/v2fly/v2ray-core/commit/c1af2bfd7aa59a4482aa7f6ec4b9208c1d350b5c</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-41099" CVSS="7.5">
    <Description>Redis is an open source, in-memory database that persists on disk. An integer overflow bug in the underlying string library can be used to corrupt the heap and potentially result with denial of service or remote code execution. The vulnerability involves changing the default proto-max-bulk-len configuration parameter to a very large value and constructing specially crafted network payloads or commands. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the proto-max-bulk-len configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.</Description>
    <URL>https://github.com/redis/redis/commit/c6ad876774f3cc11e32681ea02a2eead00f2c521</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="680">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-41195" CVSS="5.5">
    <Description>TensorFlow is an open source platform for machine learning. In affected versions the implementation of `tf.math.segment_*` operations results in a `CHECK`-fail related abort (and denial of service) if a segment id in `segment_ids` is large. This is similar to CVE-2021-29584 (and similar other reported vulnerabilities in TensorFlow, localized to specific APIs): the implementation (both on CPU and GPU) computes the output shape using `AddDim`. However, if the number of elements in the tensor overflows an `int64_t` value, `AddDim` results in a `CHECK` failure which provokes a `std::abort`. Instead, code should use `AddDimWithStatus`. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/e9c81c1e1a9cd8dd31f4e83676cab61b60658429</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-41196" CVSS="5.5">
    <Description>TensorFlow is an open source platform for machine learning. In affected versions the Keras pooling layers can trigger a segfault if the size of the pool is 0 or if a dimension is negative. This is due to the TensorFlow's implementation of pooling operations where the values in the sliding window are not checked to be strictly positive. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/12b1ff82b3f26ff8de17e58703231d5a02ef1b8b</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-41197" CVSS="5.5">
    <Description>TensorFlow is an open source platform for machine learning. In affected versions TensorFlow allows tensor to have a large number of dimensions and each dimension can be as large as desired. However, the total number of elements in a tensor must fit within an `int64_t`. If an overflow occurs, `MultiplyWithoutOverflow` would return a negative result. In the majority of TensorFlow codebase this then results in a `CHECK`-failure. Newer constructs exist which return a `Status` instead of crashing the binary. This is similar to CVE-2021-29584. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/7c1692bd417eb4f9b33ead749a41166d6080af85</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-41198" CVSS="5.5">
    <Description>TensorFlow is an open source platform for machine learning. In affected versions if `tf.tile` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/9294094df6fea79271778eb7e7ae1bad8b5ef98f</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-41199" CVSS="5.5">
    <Description>TensorFlow is an open source platform for machine learning. In affected versions if `tf.image.resize` is called with a large input argument then the TensorFlow process will crash due to a `CHECK`-failure caused by an overflow. The number of elements in the output tensor is too much for the `int64_t` type and the overflow is detected via a `CHECK` statement. This aborts the process. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/e5272d4204ff5b46136a1ef1204fc00597e21837</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-41202" CVSS="5.5">
    <Description>TensorFlow is an open source platform for machine learning. In affected versions while calculating the size of the output within the `tf.range` kernel, there is a conditional statement of type `int64 = condition ? int64 : double`. Due to C++ implicit conversion rules, both branches of the condition will be cast to `double` and the result would be truncated before the assignment. This result in overflows. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/1b0e0ec27e7895b9985076eab32445026ae5ca94</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-41203" CVSS="7.8">
    <Description>TensorFlow is an open source platform for machine learning. In affected versions an attacker can trigger undefined behavior, integer overflows, segfaults and `CHECK`-fail crashes if they can change saved checkpoints from outside of TensorFlow. This is because the checkpoints loading infrastructure is missing validation for invalid file formats. The fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/368af875869a204b4ac552b9ddda59f6a46a56ec</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-41207" CVSS="5.5">
    <Description>TensorFlow is an open source platform for machine learning. In affected versions the implementation of `ParallelConcat` misses some input validation and can produce a division by 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/f2c3931113eaafe9ef558faaddd48e00a6606235</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-41209" CVSS="5.5">
    <Description>TensorFlow is an open source platform for machine learning. In affected versions the implementations for convolution operators trigger a division by 0 if passed empty filter tensor arguments. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/f2c3931113eaafe9ef558faaddd48e00a6606235</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-41218" CVSS="5.5">
    <Description>TensorFlow is an open source platform for machine learning. In affected versions the shape inference code for `AllToAll` can be made to execute a division by 0. This occurs whenever the `split_count` argument is 0. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/a8ad3e5e79c75f36edb81e0ba3f3c0c5442aeddc</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-41222" CVSS="5.5">
    <Description>TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SplitV` can trigger a segfault is an attacker supplies negative arguments. This occurs whenever `size_splits` contains more than one value and at least one value is negative. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/25d622ffc432acc736b14ca3904177579e733cc6</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-41272" CVSS="7.5">
    <Description>Besu is an Ethereum client written in Java. Starting in version 21.10.0, changes in the implementation of the SHL, SHR, and SAR operations resulted in the introduction of a signed type coercion error in values that represent negative values for 32 bit signed integers. Smart contracts that ask for shifts between approximately 2 billion and 4 billion bits (nonsensical but valid values for the operation) will fail to execute and hence fail to validate. In networks where vulnerable versions are mining with other clients or non-vulnerable versions this will result in a fork and the relevant transactions will not be included in the fork. In networks where vulnerable versions are not mining (such as Rinkeby) no fork will result and the validator nodes will stop accepting blocks. In networks where only vulnerable versions are mining the relevant transaction will not be included in any blocks. When the network adds a non-vulnerable version the network will act as in the first case. Besu 21.10.2 contains a patch for this issue. Besu 21.7.4 is not vulnerable and clients can roll back to that version. There is a workaround available: Once a transaction with the relevant shift operations is included in the canonical chain, the only remediation is to make sure all nodes are on non-vulnerable versions.</Description>
    <URL>https://github.com/hyperledger/besu/commit/4170524ac3b45185704fcfbdeeb71b0b05dfa0a1</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-4155" CVSS="5.5">
    <Description>A data leak flaw was found in the way XFS_IOC_ALLOCSP IOCTL in the XFS filesystem allowed for size increase of files with unaligned size. A local attacker could use this flaw to leak data on the XFS filesystem otherwise not accessible to them.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=983d8e60f50806f90534cc5373d0ce867e5aaf79</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-41864" CVSS="7.8">
    <Description>prealloc_elems_and_freelist in kernel/bpf/stackmap.c in the Linux kernel before 5.14.12 allows unprivileged users to trigger an eBPF multiplication integer overflow with a resultant out-of-bounds write.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf.git/commit/?id=30e29a9a2bc6a4888335a6ede968b75cd329657a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-4216" CVSS="5.5">
    <Description>A Floating point exception (division-by-zero) flaw was found in Mupdf for zero width pages in muraster.c. It is fixed in Mupdf-1.20.0-rc1 upstream.</Description>
    <URL>https://github.com/ArtifexSoftware/mupdf/commit/22c47acbd52949421f8c7cb46ea1556827d0fcbf</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-4259" CVSS="9.8">
    <Description>A vulnerability was found in phpRedisAdmin up to 1.16.1. It has been classified as problematic. This affects the function authHttpDigest of the file includes/login.inc.php. The manipulation of the argument response leads to use of wrong operator in string comparison. Upgrading to version 1.16.2 is able to address this issue. The name of the patch is 31aa7661e6db6f4dffbf9a635817832a0a11c7d9. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216267.</Description>
    <URL>https://github.com/erikdubbelboer/phpRedisAdmin/commit/31aa7661e6db6f4dffbf9a635817832a0a11c7d9</URL>
    <CWE CWE="597">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-4327" CVSS="9.8">
    <Description>A vulnerability was found in SerenityOS. It has been rated as critical. Affected by this issue is the function initialize_typed_array_from_array_buffer in the library Userland/Libraries/LibJS/Runtime/TypedArray.cpp. The manipulation leads to integer overflow. The exploit has been disclosed to the public and may be used. Continious delivery with rolling releases is used by this product. Therefore, no version details of affected nor updated releases are available. The patch is identified as f6c6047e49f1517778f5565681fb64750b14bf60. It is recommended to apply a patch to fix this issue. VDB-222074 is the identifier assigned to this vulnerability.</Description>
    <URL>https://github.com/SerenityOS/serenity/commit/f6c6047e49f1517778f5565681fb64750b14bf60</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-43784" CVSS="5.0">
    <Description>runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc, netlink is used internally as a serialization system for specifying the relevant container configuration to the `C` portion of the code (responsible for the based namespace setup of containers). In all versions of runc prior to 1.0.3, the encoder did not handle the possibility of an integer overflow in the 16-bit length field for the byte array attribute type, meaning that a large enough malicious byte array attribute could result in the length overflowing and the attribute contents being parsed as netlink messages for container configuration. This vulnerability requires the attacker to have some control over the configuration of the container and would allow the attacker to bypass the namespace restrictions of the container by simply adding their own netlink payload which disables all namespaces. The main users impacted are those who allow untrusted images with untrusted configurations to run on their machines (such as with shared cloud infrastructure). runc version 1.0.3 contains a fix for this bug. As a workaround, one may try disallowing untrusted namespace paths from your container. It should be noted that untrusted namespace paths would allow the attacker to disable namespace protections entirely even in the absence of this bug.</Description>
    <URL>https://github.com/opencontainers/runc/commit/9c444070ec7bb83995dbc0185da68284da71c554</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-44078" CVSS="8.1">
    <Description>An issue was discovered in split_region in uc.c in Unicorn Engine before 2.0.0-rc5. It allows local attackers to escape the sandbox. An attacker must first obtain the ability to execute crafted code in the target sandbox in order to exploit this vulnerability. The specific flaw exists within the virtual memory manager. The issue results from the faulty comparison of GVA and GPA while calling uc_mem_map_ptr to free part of a claimed memory block. An attacker can leverage this vulnerability to escape the sandbox and execute arbitrary code on the host machine.</Description>
    <URL>https://github.com/unicorn-engine/unicorn/commit/c733bbada356b0373fa8aa72c044574bb855fd24</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-46389" CVSS="7.5">
    <Description>IIPImage High Resolution Streaming Image Server prior to commit 882925b295a80ec992063deffc2a3b0d803c3195 is affected by an integer overflow in iipsrv.fcgi through malformed HTTP query parameters.</Description>
    <URL>https://github.com/ruven/iipsrv/commit/4ed59265fbbd636dc2fbbf325f8ea37ed300a6d9</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2021-46829" CVSS="7.8">
    <Description>GNOME GdkPixbuf (aka GDK-PixBuf) before 2.42.8 allows a heap-based buffer overflow when compositing or clearing frames in GIF files, as demonstrated by io-gif-animation.c composite_frame. This overflow is controllable and could be abused for code execution, especially on 32-bit systems.</Description>
    <URL>https://gitlab.gnome.org/GNOME/gdk-pixbuf/-/commit/5398f04d772f7f8baf5265715696ed88db0f0512</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2021-46848" CVSS="9.1">
    <Description>GNU Libtasn1 before 4.19.0 has an ETYPE_OK off-by-one array size check that affects asn1_encode_simple_der.</Description>
    <URL>https://gitlab.com/gnutls/libtasn1/-/commit/44a700d2051a666235748970c2df047ff207aeb5</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-0185" CVSS="8.4">
    <Description>A heap-based buffer overflow flaw was found in the way the legacy_parse_param function in the Filesystem Context functionality of the Linux kernel verified the supplied parameters length. An unprivileged (in case of unprivileged user namespaces enabled, otherwise needs namespaced CAP_SYS_ADMIN privilege) local user able to open a filesystem that does not support the Filesystem Context API (and thus fallbacks to legacy handling) could use this flaw to escalate their privileges on the system.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=722d94847de2</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-0204" CVSS="8.8">
    <Description>A heap overflow vulnerability was found in bluez in versions prior to 5.63. An attacker with local network access could pass specially crafted files causing an application to halt or crash, leading to a denial of service.</Description>
    <URL>https://github.com/bluez/bluez/commit/591c546c536b42bef696d027f64aa22434f8c3f0</URL>
    <CWE CWE="119">
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-0322" CVSS="5.5">
    <Description>A flaw was found in the sctp_make_strreset_req function in net/sctp/sm_make_chunk.c in the SCTP network protocol in the Linux kernel with a local user privilege access. In this flaw, an attempt to use more buffer than is allocated triggers a BUG_ON issue, leading to a denial of service (DOS).</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a2d859e3fc97e79d907761550dbc03ff1b36479c</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-0855" CVSS="6.1">
    <Description>Improper Resolution of Path Equivalence in GitHub repository microweber-dev/whmcs_plugin prior to 0.0.4.</Description>
    <URL>https://github.com/microweber-dev/whmcs_plugin/commit/2e7a11d332db79cc52ccda00455a15f4dc6147ff</URL>
    <CWE CWE="41">
      <MainWeakness Cause="Under-Restrictive Policy" Operation="Sanitize" Consequence="File Injection" />
    </CWE>
    <CWE CWE="706">
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Object Resolved" />
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Function Resolved" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-0913" CVSS="7.5">
    <Description>Integer Overflow or Wraparound in GitHub repository microweber/microweber prior to 1.3.</Description>
    <URL>https://github.com/microweber/microweber/commit/7559e141d0707f8eeff2f9aeaa5a0ca2e3fe6583</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-0961" CVSS="5.5">
    <Description>The microweber application allows large characters to insert in the input field "post title" which can allow attackers to cause a Denial of Service (DoS) via a crafted HTTP request. in GitHub repository microweber/microweber prior to 1.2.12.</Description>
    <URL>https://github.com/microweber/microweber/commit/f7acbd075dff4825b35b597b74958de9edce67fc</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-0968" CVSS="5.5">
    <Description>The microweber application allows large characters to insert in the input field "fist &amp; last name" which can allow attackers to cause a Denial of Service (DoS) via a crafted HTTP request. in microweber/microweber in GitHub repository microweber/microweber prior to 1.2.12.</Description>
    <URL>https://github.com/microweber/microweber/commit/80e39084729a57dfe749626c3b9d35247a14c49e</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-1036" CVSS="7.5">
    <Description>Able to create an account with long password leads to memory corruption / Integer Overflow in GitHub repository microweber/microweber prior to 1.2.12.</Description>
    <URL>https://github.com/microweber/microweber/commit/82be4f0b4729be870ccefdae99a04833f134aa6a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-1116" CVSS="7.8">
    <Description>Integer Overflow or Wraparound vulnerability in io_uring of Linux Kernel allows local attacker to cause memory corruption and escalate privileges to root. This issue affects: Linux Kernel versions prior to 5.4.189; version 5.4.24 and later versions.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/fs/io_uring.c?h=v5.4.189&amp;id=1a623d361ffe5cecd4244a02f449528416360038</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-1698" CVSS="7.5">
    <Description>Allowing long password leads to denial of service in GitHub repository causefx/organizr prior to 2.1.2000. This vulnerability can be abused by doing a DDoS attack for which genuine users will not able to access resources/applications.</Description>
    <URL>https://github.com/causefx/organizr/commit/e4b4cff66c526f7b5bbaef0073c92c315c29bd56</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-1699" CVSS="7.5">
    <Description>Uncontrolled Resource Consumption in GitHub repository causefx/organizr prior to 2.1.2000. This vulnerability can be abused by doing a DDoS attack for which genuine users will not able to access resources/applications.</Description>
    <URL>https://github.com/causefx/organizr/commit/e4b4cff66c526f7b5bbaef0073c92c315c29bd56</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="400">
      <MainWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Memory Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
      <MainWeakness Cause="Single Owned Address" Operation="Reassign" Consequence="Memory Leak" />
      <MainWeakness Cause="Missing Code" Operation="Deallocate" Consequence="Memory Leak" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-1718" CVSS="7.5">
    <Description>The trudesk application allows large characters to insert in the input field "Full Name" on the signup field which can allow attackers to cause a Denial of Service (DoS) via a crafted HTTP request in GitHub repository polonel/trudesk prior to 1.2.2. This can lead to Denial of service.</Description>
    <URL>https://github.com/polonel/trudesk/commit/87e231e04495fb705fe1e03cb56fc4136bafe895</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-1728" CVSS="6.5">
    <Description>Allowing long password leads to denial of service in polonel/trudesk in GitHub repository polonel/trudesk prior to 1.2.2. This vulnerability can be abused by doing a DDoS attack for which genuine users will not able to access resources/applications.</Description>
    <URL>https://github.com/polonel/trudesk/commit/e836d04d16787c2c9c72e7bf011cf396d1f73c19</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-1754" CVSS="6.5">
    <Description>Integer Overflow or Wraparound in GitHub repository polonel/trudesk prior to 1.2.2.</Description>
    <URL>https://github.com/polonel/trudesk/commit/e836d04d16787c2c9c72e7bf011cf396d1f73c19</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-1812" CVSS="9.8">
    <Description>Integer Overflow or Wraparound in GitHub repository publify/publify prior to 9.2.10.</Description>
    <URL>https://github.com/publify/publify/commit/29a5837c29620e33857d7a5afce01384e3f8e41a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-1926" CVSS="4.9">
    <Description>Integer Overflow or Wraparound in GitHub repository polonel/trudesk prior to 1.2.3.</Description>
    <URL>https://github.com/polonel/trudesk/commit/b7c15180b6d4e556ad05d0881eb72d8b2f1637a0</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-21668" CVSS="8.6">
    <Description>pipenv is a Python development workflow tool. Starting with version 2018.10.9 and prior to version 2022.1.8, a flaw in pipenv's parsing of requirements files allows an attacker to insert a specially crafted string inside a comment anywhere within a requirements.txt file, which will cause victims who use pipenv to install the requirements file to download dependencies from a package index server controlled by the attacker. By embedding malicious code in packages served from their malicious index server, the attacker can trigger arbitrary remote code execution (RCE) on the victims' systems. If an attacker is able to hide a malicious `--index-url` option in a requirements file that a victim installs with pipenv, the attacker can embed arbitrary malicious code in packages served from their malicious index server that will be executed on the victim's host during installation (remote code execution/RCE). When pip installs from a source distribution, any code in the setup.py is executed by the install process. This issue is patched in version 2022.1.8. The GitHub Security Advisory contains more information about this vulnerability.</Description>
    <URL>https://github.com/pypa/pipenv/commit/439782a8ae36c4762c88e43d5f0d8e563371b46f</URL>
    <CWE CWE="20">
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Type" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Type" />
    </CWE>
    <CWE CWE="77">
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Command Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Command Injection" />
    </CWE>
    <CWE CWE="78">
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Command Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Command Injection" />
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="791">
      <MainWeakness Cause="Under-Restrictive Policy" Operation="Sanitize" Consequence="Invalid Data" />
    </CWE>
    <CWE CWE="1284">
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Inconsistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Inconsistent Value" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-21685" CVSS="6.5">
    <Description>Frontier is Substrate's Ethereum compatibility layer. Prior to commit number `8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664`, a bug in Frontier's MODEXP precompile implementation can cause an integer underflow in certain conditions. This will cause a node crash for debug builds. For release builds (and production WebAssembly binaries), the impact is limited as it can only cause a normal EVM out-of-gas. Users who do not use MODEXP precompile in their runtime are not impacted. A patch is available in pull request #549.</Description>
    <URL>https://github.com/paritytech/frontier/commit/8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-21725" CVSS="6.5">
    <Description>Tensorflow is an Open Source Machine Learning Framework. The estimator for the cost of some convolution operations can be made to execute a division by 0. The function fails to check that the stride argument is strictly positive. Hence, the fix is to add a check for the stride argument to ensure it is valid. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/3218043d6d3a019756607643cf65574fbfef5d7a</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-21727" CVSS="8.8">
    <Description>Tensorflow is an Open Source Machine Learning Framework. The implementation of shape inference for `Dequantize` is vulnerable to an integer overflow weakness. The `axis` argument can be `-1` (the default value for the optional argument) or any other positive value at most the number of dimensions of the input. Unfortunately, the upper bound is not checked, and, since the code computes `axis + 1`, an attacker can trigger an integer overflow. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/b64638ec5ccaa77b7c1eb90958e3d85ce381f91b</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-21729" CVSS="6.5">
    <Description>Tensorflow is an Open Source Machine Learning Framework. The implementation of `UnravelIndex` is vulnerable to a division by zero caused by an integer overflow bug. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/58b34c6c8250983948b5a781b426f6aa01fd47af</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-21733" CVSS="6.5">
    <Description>Tensorflow is an Open Source Machine Learning Framework. The implementation of `StringNGrams` can be used to trigger a denial of service attack by causing an out of memory condition after an integer overflow. We are missing a validation on `pad_witdh` and that result in computing a negative value for `ngram_width` which is later used to allocate parts of the output. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/f68fdab93fb7f4ddb4eb438c8fe052753c9413e8</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-21735" CVSS="6.5">
    <Description>Tensorflow is an Open Source Machine Learning Framework. The implementation of `FractionalMaxPool` can be made to crash a TensorFlow process via a division by 0. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/ba4e8ac4dc2991e350d5cc407f8598c8d4ee70fb</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-21738" CVSS="6.5">
    <Description>Tensorflow is an Open Source Machine Learning Framework. The implementation of `SparseCountSparseOutput` can be made to crash a TensorFlow process by an integer overflow whose result is then used in a memory allocation. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/6f4d3e8139ec724dbbcb40505891c81dd1052c4a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-21741" CVSS="6.5">
    <Description>Tensorflow is an Open Source Machine Learning Framework. ### Impact An attacker can craft a TFLite model that would trigger a division by zero in the implementation of depthwise convolutions. The parameters of the convolution can be user controlled and are also used within a division operation to determine the size of the padding that needs to be added before applying the convolution. There is no check before this division that the divisor is strictly positive. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/e5b0eec199c2d03de54fd6a7fd9275692218e2bc</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-2285" CVSS="7.8">
    <Description>Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.</Description>
    <URL>https://github.com/vim/vim/commit/27efc62f5d86afcb2ecb7565587fe8dea4b036fe</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-23066" CVSS="9.1">
    <Description>In Solana rBPF versions 0.2.26 and 0.2.27 are affected by Incorrect Calculation which is caused by improper implementation of sdiv instruction. This can lead to the wrong execution path, resulting in huge loss in specific cases. For example, the result of a sdiv instruction may decide whether to transfer tokens or not. The vulnerability affects both integrity and may cause serious availability problems.</Description>
    <URL>https://github.com/solana-labs/rbpf/commit/e61e045f8c244de978401d186dcfd50838817297</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-23521" CVSS="9.8">
    <Description>Git is distributed revision control system. gitattributes are a mechanism to allow defining attributes for paths. These attributes can be defined by adding a `.gitattributes` file to the repository, which contains a set of file patterns and the attributes that should be set for paths matching this pattern. When parsing gitattributes, multiple integer overflows can occur when there is a huge number of path patterns, a huge number of attributes for a single pattern, or when the declared attribute names are huge. These overflows can be triggered via a crafted `.gitattributes` file that may be part of the commit history. Git silently splits lines longer than 2KB when parsing gitattributes from a file, but not when parsing them from the index. Consequentially, the failure mode depends on whether the file exists in the working tree, the index or both. This integer overflow can result in arbitrary heap reads and writes, which may result in remote code execution. The problem has been patched in the versions published on 2023-01-17, going back to v2.30.7. Users are advised to upgrade. There are no known workarounds for this issue.</Description>
    <URL>https://github.com/git/git/commit/508386c6c5857b4faa2c3e491f422c98cc69ae76</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-23557" CVSS="6.5">
    <Description>Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would trigger a division by zero in `BiasAndClamp` implementation. There is no check that the `bias_size` is non zero. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/8c6f391a2282684a25cbfec7687bd5d35261a209</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-23558" CVSS="8.8">
    <Description>Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause an integer overflow in `TfLiteIntArrayCreate`. The `TfLiteIntArrayGetSizeInBytes` returns an `int` instead of a `size_t. An attacker can control model inputs such that `computed_size` overflows the size of `int` datatype. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/a1e1511dde36b3f8aa27a6ec630838e7ea40e091</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-23559" CVSS="8.8">
    <Description>Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause an integer overflow in embedding lookup operations. Both `embedding_size` and `lookup_size` are products of values provided by the user. Hence, a malicious user could trigger overflows in the multiplication. In certain scenarios, this can then result in heap OOB read/write. Users are advised to upgrade to a patched version.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/1de49725a5fc4e48f1a3b902ec3599ee99283043</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-23562" CVSS="8.8">
    <Description>Tensorflow is an Open Source Machine Learning Framework. The implementation of `Range` suffers from integer overflows. These can trigger undefined behavior or, in some scenarios, extremely large allocations. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/f0147751fd5d2ff23251149ebad9af9f03010732</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-23567" CVSS="6.5">
    <Description>Tensorflow is an Open Source Machine Learning Framework. The implementations of `Sparse*Cwise*` ops are vulnerable to integer overflows. These can be used to trigger large allocations (so, OOM based denial of service) or `CHECK`-fails when building new `TensorShape` objects (so, assert failures based denial of service). We are missing some validation on the shapes of the input tensors as well as directly constructing a large `TensorShape` with user-provided dimensions. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/1b54cadd19391b60b6fcccd8d076426f7221d5e8</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-23568" CVSS="6.5">
    <Description>Tensorflow is an Open Source Machine Learning Framework. The implementation of `AddManySparseToTensorsMap` is vulnerable to an integer overflow which results in a `CHECK`-fail when building new `TensorShape` objects (so, an assert failure based denial of service). We are missing some validation on the shapes of the input tensors as well as directly constructing a large `TensorShape` with user-provided dimensions. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/a68f68061e263a88321c104a6c911fe5598050a8</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-23575" CVSS="6.5">
    <Description>Tensorflow is an Open Source Machine Learning Framework. The implementation of `OpLevelCostEstimator::CalculateTensorSize` is vulnerable to an integer overflow if an attacker can create an operation which would involve a tensor with large enough number of elements. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/fcd18ce3101f245b083b30655c27b239dc72221e</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-23576" CVSS="6.5">
    <Description>Tensorflow is an Open Source Machine Learning Framework. The implementation of `OpLevelCostEstimator::CalculateOutputSize` is vulnerable to an integer overflow if an attacker can create an operation which would involve tensors with large enough number of elements. We can have a large enough number of dimensions in `output_shape.dim()` or just a small number of dimensions being large enough to cause an overflow in the multiplication. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/b9bd6cfd1c50e6807846af9a86f9b83cafc9c8ae</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-23587" CVSS="9.8">
    <Description>Tensorflow is an Open Source Machine Learning Framework. Under certain scenarios, Grappler component of TensorFlow is vulnerable to an integer overflow during cost estimation for crop and resize. Since the cropping parameters are user controlled, a malicious person can trigger undefined behavior. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/0aaaae6eca5a7175a193696383f582f53adab23f</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-23613" CVSS="7.8">
    <Description>xrdp is an open source remote desktop protocol (RDP) server. In affected versions an integer underflow leading to a heap overflow in the sesman server allows any unauthenticated attacker which is able to locally access a sesman server to execute code as root. This vulnerability has been patched in version 0.9.18.1 and above. Users are advised to upgrade. There are no known workarounds.</Description>
    <URL>https://github.com/neutrinolabs/xrdp/commit/4def30ab8ea445cdc06832a44c3ec40a506a0ffa</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-23628" CVSS="5.3">
    <Description>OPA is an open source, general-purpose policy engine. Under certain conditions, pretty-printing an abstract syntax tree (AST) that contains synthetic nodes could change the logic of some statements by reordering array literals. Example of policies impacted are those that parse and compare web paths. **All of these** three conditions have to be met to create an adverse effect: 1. An AST of Rego had to be **created programmatically** such that it ends up containing terms without a location (such as wildcard variables). 2. The AST had to be **pretty-printed** using the `github.com/open-policy-agent/opa/format` package. 3. The result of the pretty-printing had to be **parsed and evaluated again** via an OPA instance using the bundles, or the Golang packages. If any of these three conditions are not met, you are not affected. Notably, all three would be true if using **optimized bundles**, i.e. bundles created with `opa build -O=1` or higher. In that case, the optimizer would fulfil condition (1.), the result of that would be pretty-printed when writing the bundle to disk, fulfilling (2.). When the bundle was then used, we'd satisfy (3.). As a workaround users may disable optimization when creating bundles.</Description>
    <URL>https://github.com/open-policy-agent/opa/commit/932e4ffc37a590ace79e9b75ca4340288c220239</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-2454" CVSS="7.8">
    <Description>Integer Overflow or Wraparound in GitHub repository gpac/gpac prior to 2.1-DEV.</Description>
    <URL>https://github.com/gpac/gpac/commit/faa75edde3dfeba1e2cf6ffa48e45a50f1042096</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-24787" CVSS="7.5">
    <Description>Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `"\x00"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.</Description>
    <URL>https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-24795" CVSS="7.5">
    <Description>yajl-ruby is a C binding to the YAJL JSON parsing and generation library. The 1.x branch and the 2.x branch of `yajl` contain an integer overflow which leads to subsequent heap memory corruption when dealing with large (~2GB) inputs. The reallocation logic at `yajl_buf.c#L64` may result in the `need` 32bit integer wrapping to 0 when `need` approaches a value of 0x80000000 (i.e. ~2GB of data), which results in a reallocation of buf-&gt;alloc into a small heap chunk. These integers are declared as `size_t` in the 2.x branch of `yajl`, which practically prevents the issue from triggering on 64bit platforms, however this does not preclude this issue triggering on 32bit builds on which `size_t` is a 32bit integer. Subsequent population of this under-allocated heap chunk is based on the original buffer size, leading to heap memory corruption. This vulnerability mostly impacts process availability. Maintainers believe exploitation for arbitrary code execution is unlikely. A patch is available and anticipated to be part of yajl-ruby version 1.4.2. As a workaround, avoid passing large inputs to YAJL.</Description>
    <URL>https://github.com/brianmario/yajl-ruby/commit/7168bd79b888900aa94523301126f968a93eb3a6</URL>
    <CWE CWE="122">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-24845" CVSS="9.8">
    <Description>Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `&lt;iface&gt;.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `&lt;iface&gt;.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.</Description>
    <URL>https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-2493" CVSS="8.1">
    <Description>Data Access from Outside Expected Data Manager Component in GitHub repository openemr/openemr prior to 7.0.0.</Description>
    <URL>https://github.com/openemr/openemr/commit/871ae5198d8ca18fd17257ae7c5c906a52dca908</URL>
    <CWE CWE="1083">
      <MainWeakness Cause="Erroneous Code" Operation="Define" Consequence="Wrong Access Object" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-25051" CVSS="5.5">
    <Description>An Off-by-one Error occurs in cmr113_decode of rtl_433 21.12 when decoding a crafted file.</Description>
    <URL>https://github.com/merbanan/rtl_433/commit/2dad7b9fc67a1d0bfbe520fbd821678b8f8cc7a8</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-2566" CVSS="7.8">
    <Description>A heap out-of-bounds memory write exists in FFMPEG since version 5.1. The size calculation in `build_open_gop_key_points()` goes through all entries in the loop and adds `sc-&gt;ctts_data[i].count` to `sc-&gt;sample_offsets_count`. This can lead to an integer overflow resulting in a small allocation with `av_calloc()`. An attacker can cause remote code execution via a malicious mp4 file. We recommend upgrading past commit c953baa084607dd1d84c3bfcce3cf6a87c3e6e05</Description>
    <URL>https://github.com/FFmpeg/FFmpeg/commit/c953baa084607dd1d84c3bfcce3cf6a87c3e6e05</URL>
    <CWE CWE="122">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-2639" CVSS="7.8">
    <Description>An integer coercion error was found in the openvswitch kernel module. Given a sufficiently large number of actions, while copying and reserving memory for a new action of a new flow, the reserve_sfa_size() function does not return -EMSGSIZE as expected, potentially leading to an out-of-bounds write access. This flaw allows a local user to crash or potentially escalate their privileges on the system.</Description>
    <URL>https://github.com/torvalds/linux/commit/cefa91b2332d7009bc0be5d951d6cbbf349f90f8</URL>
    <CWE CWE="192">
      <MainWeakness Operation="Coerce" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-26691" CVSS="6.7">
    <Description>A logic issue was addressed with improved state management. This issue is fixed in Security Update 2022-003 Catalina, macOS Monterey 12.3, macOS Big Sur 11.6.5. An application may be able to gain elevated privileges.</Description>
    <URL>https://github.com/OpenPrinting/cups/commit/de4f8c196106033e4c372dce3e91b9d42b0b9444</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-27114" CVSS="5.5">
    <Description>There is a vulnerability in htmldoc 1.9.16. In image_load_jpeg function image.cxx when it calls malloc,'img-&gt;width' and 'img-&gt;height' they are large enough to cause an integer overflow. So, the malloc function may return a heap blosmaller than the expected size, and it will cause a buffer overflow/Address boundary error in the jpeg_read_scanlines function.</Description>
    <URL>https://github.com/michaelrsweet/htmldoc/commit/31f780487e5ddc426888638786cdc47631687275</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-29203" CVSS="5.5">
    <Description>TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.SpaceToBatchND` (in all backends such as XLA and handwritten kernels) is vulnerable to an integer overflow: The result of this integer overflow is used to allocate the output tensor, hence we get a denial of service via a `CHECK`-failure (assertion failure), as in TFSA-2021-198. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/acd56b8bcb72b163c834ae4f18469047b001fadf</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-29204" CVSS="5.5">
    <Description>TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.UnsortedSegmentJoin` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. The code assumes `num_segments` is a positive scalar but there is no validation. Since this value is used to allocate the output tensor, a negative value would result in a `CHECK`-failure (assertion failure), as per TFSA-2021-198. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/20cb18724b0bf6c09071a3f53434c4eec53cc147</URL>
    <CWE CWE="20">
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Type" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Type" />
    </CWE>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-29824" CVSS="6.5">
    <Description>In libxml2 before 2.9.14, several buffer handling functions in buf.c (xmlBuf*) and tree.c (xmlBuffer*) don't check for integer overflows. This can result in out-of-bounds memory writes. Exploitation requires a victim to open a crafted, multi-gigabyte XML file. Other software using libxml2's buffer functions, for example libxslt through 1.1.35, is affected as well.</Description>
    <URL>https://gitlab.gnome.org/GNOME/libxml2/-/commit/2554a2408e09f13652049e5ffb0d26196b02ebab</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-3061" CVSS="5.5">
    <Description>Found Linux Kernel flaw in the i740 driver. The Userspace program could pass any values to the driver through ioctl() interface. The driver doesn't check the value of 'pixclock', so it may cause a divide by zero error.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/deller/linux-fbdev.git/commit/?id=15cf0b82271b1823fb02ab8c377badba614d95d5</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-31005" CVSS="7.5">
    <Description>Vapor is an HTTP web framework for Swift. Users of Vapor prior to version 4.60.3 with FileMiddleware enabled are vulnerable to an integer overflow vulnerability that can crash the application. Version 4.60.3 contains a patch for this issue. As a workaround, disable FileMiddleware and serve via a Content Delivery Network.</Description>
    <URL>https://github.com/vapor/vapor/commit/953a349b539b3e0d3653585c8ffb50c427986df1</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-31089" CVSS="7.5">
    <Description>Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. In affected versions certain types of invalid files requests are not handled properly and can crash the server. If you are running multiple Parse Server instances in a cluster, the availability impact may be low; if you are running Parse Server as single instance without redundancy, the availability impact may be high. This issue has been addressed in versions 4.10.12 and 5.2.3. Users are advised to upgrade. There are no known workarounds for this issue.</Description>
    <URL>https://github.com/parse-community/parse-server/commit/5be375dec2fa35425c1003ae81c55995ac72af92</URL>
    <CWE CWE="706">
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Object Resolved" />
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Function Resolved" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-31169" CVSS="7.5">
    <Description>Wasmtime is a standalone runtime for WebAssembly. There is a bug in Wasmtime's code generator, Cranelift, for AArch64 targets where constant divisors can result in incorrect division results at runtime. This affects Wasmtime prior to version 0.38.2 and Cranelift prior to 0.85.2. This issue only affects the AArch64 platform. Other platforms are not affected. The translation rules for constants did not take into account whether sign or zero-extension should happen which resulted in an incorrect value being placed into a register when a division was encountered. The impact of this bug is that programs executing within the WebAssembly sandbox would not behave according to the WebAssembly specification. This means that it is hypothetically possible for execution within the sandbox to go awry and WebAssembly programs could produce unexpected results. This should not impact hosts executing WebAssembly but does affect the correctness of guest programs. This bug has been patched in Wasmtime version 0.38.2 and cranelift-codegen 0.85.2. There are no known workarounds.</Description>
    <URL>https://github.com/bytecodealliance/wasmtime/commit/2ba4bce5cc719e5a74e571a534424614e62ecc41</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-3165" CVSS="6.5">
    <Description>An integer underflow issue was found in the QEMU VNC server while processing ClientCutText messages in the extended format. A malicious client could use this flaw to make QEMU unresponsive by sending a specially crafted payload message, resulting in a denial of service.</Description>
    <URL>https://gitlab.com/qemu-project/qemu/-/commit/d307040b18</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-32545" CVSS="7.8">
    <Description>A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned char' at coders/psd.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/9c9a84cec4ab28ee0b57c2b9266d6fbe68183512</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-32546" CVSS="7.8">
    <Description>A vulnerability was found in ImageMagick, causing an outside the range of representable values of type 'unsigned long' at coders/pcl.c, when crafted or untrusted input is processed. This leads to a negative impact to application availability or other problems related to undefined behavior.</Description>
    <URL>https://github.com/ImageMagick/ImageMagick/commit/f221ea0fa3171f0f4fdf74ac9d81b203b9534c23</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-33068" CVSS="5.5">
    <Description>An integer overflow in the component hb-ot-shape-fallback.cc of Harfbuzz v4.3.0 allows attackers to cause a Denial of Service (DoS) via unspecified vectors.</Description>
    <URL>https://github.com/harfbuzz/harfbuzz/commit/62e803b36173fd096d7ad460dd1d1db9be542593</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-35289" CVSS="9.8">
    <Description>A write-what-where condition in hermes caused by an integer overflow, prior to commit 5b6255ae049fa4641791e47fad994e8e8c4da374 allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.</Description>
    <URL>https://github.com/facebook/hermes/commit/5b6255ae049fa4641791e47fad994e8e8c4da374</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="680">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-35940" CVSS="7.5">
    <Description>TensorFlow is an open source platform for machine learning. The `RaggedRangOp` function takes an argument `limits` that is eventually used to construct a `TensorShape` as an `int64`. If `limits` is a very large float, it can overflow when converted to an `int64`. This triggers an `InvalidArgument` but also throws an abort signal that crashes the program. We have patched the issue in GitHub commit 37cefa91bee4eace55715eeef43720b958a01192. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/37cefa91bee4eace55715eeef43720b958a01192</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-35977" CVSS="5.5">
    <Description>Redis is an in-memory database that persists on disk. Authenticated users issuing specially crafted `SETRANGE` and `SORT(_RO)` commands can trigger an integer overflow, resulting with Redis attempting to allocate impossible amounts of memory and abort with an out-of-memory (OOM) panic. The problem is fixed in Redis versions 7.0.8, 6.2.9 and 6.0.17. Users are advised to upgrade. There are no known workarounds for this vulnerability.</Description>
    <URL>https://github.com/redis/redis/commit/1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-35996" CVSS="7.5">
    <Description>TensorFlow is an open source platform for machine learning. If `Conv2D` is given empty `input` and the `filter` and `padding` sizes are valid, the output is all-zeros. This causes division-by-zero floating point exceptions that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 611d80db29dd7b0cfb755772c69d60ae5bca05f9. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/611d80db29dd7b0cfb755772c69d60ae5bca05f9</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-36008" CVSS="6.5">
    <Description>Frontier is Substrate's Ethereum compatibility layer. A security issue was discovered affecting parsing of the RPC result of the exit reason in case of EVM reversion. In release build, this would cause the exit reason being incorrectly parsed and returned by RPC. In debug build, this would cause an overflow panic. No action is needed unless you have a bridge node that needs to distinguish different reversion exit reasons and you used RPC for this. There are currently no known workarounds.</Description>
    <URL>https://github.com/paritytech/frontier/commit/fff8cc43b7756ce3979a38fc473f38e6e24ac451</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-36015" CVSS="7.5">
    <Description>TensorFlow is an open source platform for machine learning. When `RangeSize` receives values that do not fit into an `int64_t`, it crashes. We have patched the issue in GitHub commit 37e64539cd29fcfb814c4451152a60f5d107b0f0. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/37e64539cd29fcfb814c4451152a60f5d107b0f0</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-3821" CVSS="5.5">
    <Description>An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.</Description>
    <URL>https://github.com/systemd/systemd/commit/9102c625a673a3246d7e73d8737f3494446bad4e</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-38266" CVSS="6.5">
    <Description>An issue in the Leptonica linked library (v1.79.0) allows attackers to cause an arithmetic exception leading to a Denial of Service (DoS) via a crafted JPEG file.</Description>
    <URL>https://github.com/DanBloomberg/leptonica/commit/f062b42c0ea8dddebdc6a152fd16152de215d614</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-39274" CVSS="9.8">
    <Description>LoRaMac-node is a reference implementation and documentation of a LoRa network node. Versions of LoRaMac-node prior to 4.7.0 are vulnerable to a buffer overflow. Improper size validation of the incoming radio frames can lead to an 65280-byte out-of-bounds write. The function `ProcessRadioRxDone` implicitly expects incoming radio frames to have at least a payload of one byte or more. An empty payload leads to a 1-byte out-of-bounds read of user controlled content when the payload buffer is reused. This allows an attacker to craft a FRAME_TYPE_PROPRIETARY frame with size -1 which results in an 65280-byte out-of-bounds memcopy likely with partially controlled attacker data. Corrupting a large part if the data section is likely to cause a DoS. If the large out-of-bounds write does not immediately crash the attacker may gain control over the execution due to now controlling large parts of the data section. Users are advised to upgrade either by updating their package or by manually applying the patch commit `e851b079`.</Description>
    <URL>https://github.com/Lora-net/LoRaMac-node/commit/e851b079c82ba1bcf3f4d291ab69a571b0bf458a</URL>
    <CWE CWE="120">
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
      <MainWeakness Cause="Not Enough Memory" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Not Enough Memory" />
      </MainWeakness>
    </CWE>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-39308" CVSS="5.9">
    <Description>GoCD is a continuous delivery server. GoCD helps you automate and streamline the build-test-release cycle for continuous delivery of your product. GoCD versions from 19.2.0 to 19.10.0 (inclusive) are subject to a timing attack in validation of access tokens due to use of regular string comparison for validation of the token rather than a constant time algorithm. This could allow a brute force attack on GoCD server API calls to observe timing differences in validations in order to guess an access token generated by a user for API access. This issue is fixed in GoCD version 19.11.0. As a workaround, users can apply rate limiting or insert random delays to API calls made to GoCD Server via a reverse proxy or other fronting web server. Another workaround, users may disallow use of access tokens by users by having an administrator revoke all access tokens through the "Access Token Management" admin function.</Description>
    <URL>https://github.com/gocd/gocd/commit/236d4baf92e6607f2841c151c855adcc477238b8</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-39309" CVSS="6.5">
    <Description>GoCD is a continuous delivery server. GoCD helps you automate and streamline the build-test-release cycle for continuous delivery of your product. GoCD versions prior to 21.1.0 leak the symmetric key used to encrypt/decrypt any secure variables/secrets in GoCD configuration to authenticated agents. A malicious/compromised agent may then expose that key from memory, and potentially allow an attacker the ability to decrypt secrets intended for other agents/environments if they also are able to obtain access to encrypted configuration values from the GoCD server. This issue is fixed in GoCD version 21.1.0. There are currently no known workarounds.</Description>
    <URL>https://github.com/gocd/gocd/commit/691b479f1310034992da141760e9c5d1f5b60e8a</URL>
    <CWE CWE="499">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" Consequence="Wrong Access Object" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-39318" CVSS="5.7">
    <Description>FreeRDP is a free remote desktop protocol library and clients. Affected versions of FreeRDP are missing input validation in `urbdrc` channel. A malicious server can trick a FreeRDP based client to crash with division by zero. This issue has been addressed in version 2.9.0. All users are advised to upgrade. Users unable to upgrade should not use the `/usb` redirection switch.</Description>
    <URL>https://github.com/FreeRDP/FreeRDP/commit/80adde17ddc4b596ed1dae0922a0c54ab3d4b8ea</URL>
    <CWE CWE="20">
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Type" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Type" />
    </CWE>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-39842" CVSS="6.1">
    <Description>An issue was discovered in the Linux kernel before 5.19. In pxa3xx_gcu_write in drivers/video/fbdev/pxa3xx-gcu.c, the count parameter has a type conflict of size_t versus int, causing an integer overflow and bypassing the size check. After that, because it is used as the third argument to copy_from_user(), a heap overflow may occur. NOTE: the original discoverer disputes that the overflow can actually happen.</Description>
    <URL>https://github.com/torvalds/linux/commit/a09d2d00af53b43c6f11e6ab3cb58443c2cac8a7</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-40138" CVSS="9.8">
    <Description>An integer conversion error in Hermes bytecode generation, prior to commit 6aa825e480d48127b480b08d13adf70033237097, could have been used to perform Out-Of-Bounds operations and subsequently execute arbitrary code. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.</Description>
    <URL>https://github.com/facebook/hermes/commit/6aa825e480d48127b480b08d13adf70033237097</URL>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-40303" CVSS="7.5">
    <Description>An issue was discovered in libxml2 before 2.10.3. When parsing a multi-gigabyte XML document with the XML_PARSE_HUGE parser option enabled, several integer counters can overflow. This results in an attempt to access an array at a negative 2GB offset, typically leading to a segmentation fault.</Description>
    <URL>https://gitlab.gnome.org/GNOME/libxml2/-/commit/c846986356fc149915a74972bf198abc266bc2c0</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-41409" CVSS="7.5">
    <Description>Integer overflow vulnerability in pcre2test before 10.41 allows attackers to cause a denial of service or other unspecified impacts via negative input.</Description>
    <URL>https://github.com/PCRE2Project/pcre2/commit/94e1c001761373b7d9450768aa15d04c25547a35</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-41885" CVSS="7.5">
    <Description>TensorFlow is an open source platform for machine learning. When `tf.raw_ops.FusedResizeAndPadConv2D` is given a large tensor shape, it overflows. We have patched the issue in GitHub commit d66e1d568275e6a2947de97dca7a102a211e01ce. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/d66e1d568275e6a2947de97dca7a102a211e01ce</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-41886" CVSS="7.5">
    <Description>TensorFlow is an open source platform for machine learning. When `tf.raw_ops.ImageProjectiveTransformV2` is given a large output shape, it overflows. We have patched the issue in GitHub commit 8faa6ea692985dbe6ce10e1a3168e0bd60a723ba. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/8faa6ea692985dbe6ce10e1a3168e0bd60a723ba</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-41887" CVSS="7.5">
    <Description>TensorFlow is an open source platform for machine learning. `tf.keras.losses.poisson` receives a `y_pred` and `y_true` that are passed through `functor::mul` in `BinaryOp`. If the resulting dimensions overflow an `int32`, TensorFlow will crash due to a size mismatch during broadcast assignment. We have patched the issue in GitHub commit c5b30379ba87cbe774b08ac50c1f6d36df4ebb7c. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1 and 2.9.3, as these are also affected and still in supported range. However, we will not cherrypick this commit into TensorFlow 2.8.x, as it depends on Eigen behavior that changed between 2.8 and 2.9.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/c5b30379ba87cbe774b08ac50c1f6d36df4ebb7c</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-41903" CVSS="9.8">
    <Description>Git is distributed revision control system. `git log` can display commits in an arbitrary format using its `--format` specifiers. This functionality is also exposed to `git archive` via the `export-subst` gitattribute. When processing the padding operators, there is a integer overflow in `pretty.c::format_and_pad_commit()` where a `size_t` is stored improperly as an `int`, and then added as an offset to a `memcpy()`. This overflow can be triggered directly by a user running a command which invokes the commit formatting machinery (e.g., `git log --format=...`). It may also be triggered indirectly through git archive via the export-subst mechanism, which expands format specifiers inside of files within the repository during a git archive. This integer overflow can result in arbitrary heap writes, which may result in arbitrary code execution. The problem has been patched in the versions published on 2023-01-17, going back to v2.30.7. Users are advised to upgrade. Users who are unable to upgrade should disable `git archive` in untrusted repositories. If you expose git archive via `git daemon`, disable it by running `git config --global daemon.uploadArch false`.</Description>
    <URL>https://github.com/git/git/commit/508386c6c5857b4faa2c3e491f422c98cc69ae76</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-41907" CVSS="7.5">
    <Description>TensorFlow is an open source platform for machine learning. When `tf.raw_ops.ResizeNearestNeighborGrad` is given a large `size` input, it overflows. We have patched the issue in GitHub commit 00c821af032ba9e5f5fa3fe14690c8d28a657624. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/00c821af032ba9e5f5fa3fe14690c8d28a657624</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-42898" CVSS="8.8">
    <Description>PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has "a similar bug."</Description>
    <URL>https://github.com/krb5/krb5/commit/ea92d2f0fcceb54a70910fa32e9a0d7a5afc3583</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-4293" CVSS="5.5">
    <Description>Floating Point Comparison with Incorrect Operator in GitHub repository vim/vim prior to 9.0.0804.</Description>
    <URL>https://github.com/vim/vim/commit/cdef1cefa2a440911c727558562f83ed9b00e16b</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <CWE CWE="1077">
      <MainWeakness Operation="Evaluate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-43945" CVSS="7.5">
    <Description>The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f90497a16e434c2211c66e3de8e77b17868382b8</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <CWE CWE="770">
      <MainWeakness Cause="Wrong Size" Operation="Allocate" Consequence="Memory Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-4398" CVSS="7.8">
    <Description>Integer Overflow or Wraparound in GitHub repository radareorg/radare2 prior to 5.8.0.</Description>
    <URL>https://github.com/radareorg/radare2/commit/b53a1583d05c3a5bfe5fa60da133fe59dfbb02b8</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-45934" CVSS="7.8">
    <Description>An issue was discovered in the Linux kernel through 6.0.10. l2cap_config_req in net/bluetooth/l2cap_core.c has an integer wraparound via L2CAP_CONF_REQ packets.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?id=ae4569813a6e931258db627cdfe50dfb4f917d5d</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-47034" CVSS="9.8">
    <Description>A type juggling vulnerability in the component /auth/fn.php of PlaySMS v1.4.5 and earlier allows attackers to bypass authentication.</Description>
    <URL>https://github.com/playsms/playsms/commit/dd23673a00c052e113c6d44eb629dc355d3c0605</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2022-47517" CVSS="7.5">
    <Description>An issue was discovered in the libsofia-sip fork in drachtio-server before 0.8.19. It allows remote attackers to cause a denial of service (daemon crash) via a crafted UDP message that causes a url_canonize2 heap-based buffer over-read because of an off-by-one error.</Description>
    <URL>https://github.com/davehorton/sofia-sip/commit/22c1bd191f0acbf11f0c0fbea1845d9bf9dcd47e</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2022-48468" CVSS="5.5">
    <Description>protobuf-c before 1.4.1 has an unsigned integer overflow in parse_required_member.</Description>
    <URL>https://github.com/protobuf-c/protobuf-c/commit/ec3d900001a13ccdaa8aef996b34c61159c76217</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-0512" CVSS="7.8">
    <Description>Divide By Zero in GitHub repository vim/vim prior to 9.0.1247.</Description>
    <URL>https://github.com/vim/vim/commit/870219c58c0804bdc55419b2e455c06ac715a835</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-0818" CVSS="5.5">
    <Description>Off-by-one Error in GitHub repository gpac/gpac prior to v2.3.0-DEV.</Description>
    <URL>https://github.com/gpac/gpac/commit/377ab25f3e502db2934a9cf4b54739e1c89a02ff</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-1127" CVSS="7.8">
    <Description>Divide By Zero in GitHub repository vim/vim prior to 9.0.1367.</Description>
    <URL>https://github.com/vim/vim/commit/e0f869196930ef5f25a0ac41c9215b09c9ce2d3c</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-1175" CVSS="6.6">
    <Description>Incorrect Calculation of Buffer Size in GitHub repository vim/vim prior to 9.0.1378.</Description>
    <URL>https://github.com/vim/vim/commit/c99cbf8f289bdda5d4a77d7ec415850a520330ba</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-2163" CVSS="8.8">
    <Description>Incorrect verifier pruning in BPF in Linux Kernel &gt;=5.4 leads to unsafe
code paths being incorrectly marked as safe, resulting in arbitrary read/write in
kernel memory, lateral privilege escalation, and container escape.
</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=71b547f561247897a0a14f3082730156c0533fed</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-22458" CVSS="5.5">
    <Description>Redis is an in-memory database that persists on disk. Authenticated users can issue a `HRANDFIELD` or `ZRANDMEMBER` command with specially crafted arguments to trigger a denial-of-service by crashing Redis with an assertion failure. This problem affects Redis versions 6.2 or newer up to but not including 6.2.9 as well as versions 7.0 up to but not including 7.0.8. Users are advised to upgrade. There are no known workarounds for this vulnerability.</Description>
    <URL>https://github.com/redis/redis/commit/16f408b1a0121cacd44cbf8aee275d69dc627f02</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-23144" CVSS="5.5">
    <Description>Integer overflow vulnerability in function Q_DecCoordOnUnitSphere file bifs/unquantize.c in GPAC version 2.2-rev0-gab012bbfb-master.</Description>
    <URL>https://github.com/gpac/gpac/commit/3a2458a49b3e6399709d456d7b35e7a6f50cfb86</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-24533" CVSS="7.5">
    <Description>Multiplication of certain unreduced P-256 scalars produce incorrect results. There are no protocols known at this time that can be attacked due to this.</Description>
    <URL>https://github.com/FiloSottile/nistec/commit/c58aa1223ccf3943513e1e661cebce95af137244</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-24817" CVSS="7.5">
    <Description>RIOT-OS, an operating system for Internet of Things (IoT) devices, contains a network stack with the ability to process 6LoWPAN frames. Prior to version 2023.04, an attacker can send a crafted frame to the device resulting in an integer underflow and out of bounds access in the packet buffer. Triggering the access at the right time will corrupt other packets or the allocator metadata. Corrupting a pointer will lead to denial of service. This issue is fixed in version 2023.04. As a workaround, disable SRH in the network stack.</Description>
    <URL>https://github.com/RIOT-OS/RIOT/commit/34dc1757f5621be48e226cfebb2f4c63505b5360</URL>
    <CWE CWE="119">
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
        <OtherWeakness Cause="Wrong Index" Operation="Reassign" Consequence="Over Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="787">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-25155" CVSS="6.5">
    <Description>Redis is an in-memory database that persists on disk. Authenticated users issuing specially crafted `SRANDMEMBER`, `ZRANDMEMBER`, and `HRANDFIELD` commands can trigger an integer overflow, resulting in a runtime assertion and termination of the Redis server process. This problem affects all Redis versions. Patches were released in Redis version(s) 6.0.18, 6.2.11 and 7.0.9.</Description>
    <URL>https://github.com/redis/redis/commit/2a2a582e7cd99ba3b531336b8bd41df2b566e619</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-25662" CVSS="7.5">
    <Description>TensorFlow is an open source platform for machine learning. Versions prior to 2.12.0 and 2.11.1 are vulnerable to integer overflow in EditDistance. A fix is included in TensorFlow version 2.12.0 and version 2.11.1.
</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/08b8e18643d6dcde00890733b270ff8d9960c56c</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-25666" CVSS="7.5">
    <Description>TensorFlow is an open source platform for machine learning. Prior to versions 2.12.0 and 2.11.1, there is a floating point exception in AudioSpectrogram. A fix is included in TensorFlow version 2.12.0 and version 2.11.1.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/d0d4e779da0d0f56499c6fa5ba09f0a576cc6b14</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-25667" CVSS="7.5">
    <Description>TensorFlow is an open source platform for machine learning. Prior to versions 2.12.0 and 2.11.1, integer overflow occurs when `2^31 &lt;= num_frames * height * width * channels &lt; 2^32`, for example Full HD screencast of at least 346 frames. A fix is included in TensorFlow version 2.12.0 and version 2.11.1.
</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/8dc723fcdd1a6127d6c970bd2ecb18b019a1a58d</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-25669" CVSS="7.5">
    <Description>TensorFlow is an open source platform for machine learning. Prior to versions 2.12.0 and 2.11.1, if the stride and window size are not positive for `tf.raw_ops.AvgPoolGrad`, it can give a floating point exception. A fix is included in TensorFlow version 2.12.0 and version 2.11.1.
</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/1295ae4dbb52fe06b19733b0257e2340d7b63b8d</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-25673" CVSS="7.5">
    <Description>TensorFlow is an open source platform for machine learning. Versions prior to 2.12.0 and 2.11.1 have a Floating Point Exception in TensorListSplit with XLA. A fix is included in TensorFlow version 2.12.0 and version 2.11.1.
</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/728113a3be690facad6ce436660a0bc1858017fa</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-25675" CVSS="7.5">
    <Description>TensorFlow is an open source machine learning platform. When running versions prior to 2.12.0 and 2.11.1 with XLA, `tf.raw_ops.Bincount` segfaults when given a parameter `weights` that is neither the same shape as parameter `arr` nor a length-0 tensor. A fix is included in TensorFlow 2.12.0 and 2.11.1.</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/8ae76cf085f4be26295d2ecf2081e759e04b8acf</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-2610" CVSS="7.8">
    <Description>Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.1532.</Description>
    <URL>https://github.com/vim/vim/commit/ab9a2d884b3a4abe319606ea95a5a6d6b01cd73a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-26488" CVSS="6.5">
    <Description>OpenZeppelin Contracts is a library for secure smart contract development. The ERC721Consecutive contract designed for minting NFTs in batches does not update balances when a batch has size 1 and consists of a single token. Subsequent transfers from the receiver of that token may overflow the balance as reported by `balanceOf`. The issue exclusively presents with batches of size 1. The issue has been patched in 4.8.2.</Description>
    <URL>https://github.com/OpenZeppelin/openzeppelin-contracts/commit/167bf67ed3907f4a674043496019fa346cee7705</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-27477" CVSS="4.3">
    <Description>wasmtime is a fast and secure runtime for WebAssembly. Wasmtime's code generation backend, Cranelift, has a bug on x86_64 platforms for the WebAssembly `i8x16.select` instruction which will produce the wrong results when the same operand is provided to the instruction and some of the selected indices are greater than 16. There is an off-by-one error in the calculation of the mask to the `pshufb` instruction which causes incorrect results to be returned if lanes are selected from the second vector. This codegen bug has been fixed in Wasmtiem 6.0.1, 5.0.1, and 4.0.1. Users are recommended to upgrade to these updated versions. If upgrading is not an option for you at this time, you can avoid this miscompilation by disabling the Wasm simd proposal. Additionally the bug is only present on x86_64 hosts. Other platforms such as AArch64 and s390x are not affected.</Description>
    <URL>https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-27579" CVSS="7.5">
    <Description>TensorFlow is an end-to-end open source platform for machine learning. Constructing a tflite model with a paramater `filter_input_channel` of less than 1 gives a FPE. This issue has been patched in version 2.12. TensorFlow will also cherrypick the fix commit on TensorFlow 2.11.1.
</Description>
    <URL>https://github.com/tensorflow/tensorflow/commit/34f8368c535253f5c9cb3a303297743b62442aaa</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-28097" CVSS="7.5">
    <Description>OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.9 and 3.2.6, a malformed SIP message containing a large _Content-Length_ value and a specially crafted Request-URI causes a segmentation fault in OpenSIPS. This issue occurs when a large amount of shared memory using the `-m` flag was allocated to OpenSIPS, such as 10 GB of RAM. On the test system, this issue occurred when shared memory was set to `2362` or higher. This issue is fixed in versions 3.1.9 and 3.2.6. The only workaround is to guarantee that the Content-Length value of input messages is never larger than `2147483647`.</Description>
    <URL>https://github.com/OpenSIPS/opensips/commit/7cab422e2fc648f910abba34f3f0dbb3ae171ff5</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-2839" CVSS="7.5">
    <Description>Divide By Zero in GitHub repository gpac/gpac prior to 2.2.2.</Description>
    <URL>https://github.com/gpac/gpac/commit/047f96fb39e6bf70cb9f344093f5886e51dce0ac</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-28431" CVSS="7.5">
    <Description>Frontier is an Ethereum compatibility layer for Substrate. Frontier's `modexp` precompile uses `num-bigint` crate under the hood. In the implementation prior to pull request 1017, the cases for modulus being even and modulus being odd are treated separately. Odd modulus uses the fast Montgomery multiplication, and even modulus uses the slow plain power algorithm. This gas cost discrepancy was not accounted for in the `modexp` precompile, leading to possible denial of service attacks.

No fixes for `num-bigint` are currently available, and thus this issue is fixed in the short term by raising the gas costs for even modulus, and in the long term fixing it in `num-bigint` or switching to another modexp implementation. The short-term fix for Frontier is deployed at pull request 1017. There are no known workarounds aside from applying the fix.</Description>
    <URL>https://github.com/paritytech/frontier/commit/5af12e94d7dfc8a0208a290643a800f55de7b219</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-28628" CVSS="6.1">
    <Description>lambdaisland/uri is a pure Clojure/ClojureScript URI library. In versions prior to 1.14.120 `authority-regex` allows an attacker to send malicious URLs to be parsed by the `lambdaisland/uri` and return the wrong authority. This issue is similar to but distinct from CVE-2020-8910. The regex in question doesn't handle the backslash (`\`) character in the username correctly, leading to a wrong output. ex. a payload of `https://example.com\\@google.com` would return that the host is `google.com`, but the correct host should be `example.com`. Given that the library returns the wrong authority this may be abused to bypass host restrictions depending on how the library is used in an application. Users are advised to upgrade. There are no known workarounds for this vulnerability.</Description>
    <URL>https://github.com/lambdaisland/uri/commit/f46db3e84846f79e14bfee0101d9c7a872321820</URL>
    <CWE CWE="706">
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Object Resolved" />
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Function Resolved" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-30207" CVSS="5.5">
    <Description>A divide by zero issue discovered in Kodi Home Theater Software 19.5 and earlier allows attackers to cause a denial of service via use of crafted mp3 file.</Description>
    <URL>https://github.com/xbmc/xbmc/commit/dbc00c500f4c4830049cc040a61c439c580eea73</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-31137" CVSS="7.5">
    <Description>MaraDNS is open-source software that implements the Domain Name System (DNS). In version 3.5.0024 and prior, a remotely exploitable integer underflow vulnerability in the DNS packet decompression function allows an attacker to cause a Denial of Service by triggering an abnormal program termination.

The vulnerability exists in the `decomp_get_rddata` function within the `Decompress.c` file. When handling a DNS packet with an Answer RR of qtype 16 (TXT record) and any qclass, if the `rdlength` is smaller than `rdata`, the result of the line `Decompress.c:886` is a negative number `len = rdlength - total;`. This value is then passed to the `decomp_append_bytes` function without proper validation, causing the program to attempt to allocate a massive chunk of memory that is impossible to allocate. Consequently, the program exits with an error code of 64, causing a Denial of Service.

One proposed fix for this vulnerability is to patch `Decompress.c:887` by breaking `if(len &lt;= 0)`, which has been incorporated in version 3.5.0036 via commit bab062bde40b2ae8a91eecd522e84d8b993bab58.</Description>
    <URL>https://github.com/samboy/MaraDNS/commit/bab062bde40b2ae8a91eecd522e84d8b993bab58</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-3161" CVSS="5.5">
    <Description>A flaw was found in the Framebuffer Console (fbcon) in the Linux Kernel. When providing font-&gt;width and font-&gt;height greater than 32 to fbcon_set_font, since there are no checks in place, a shift-out-of-bounds occurs leading to undefined behavior and possible denial of service.</Description>
    <URL>https://github.com/torvalds/linux/commit/2b09d5d364986f724f17001ccfe4126b9b43a0be</URL>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="1335">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-32058" CVSS="7.5">
    <Description>Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.</Description>
    <URL>https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-32059" CVSS="7.5">
    <Description>Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.</Description>
    <URL>https://github.com/vyperlang/vyper/commit/c3e68c302aa6e1429946473769dd1232145822ac</URL>
    <CWE CWE="683">
      <MainWeakness Cause="Erroneous Code" Operation="Call" Consequence="Wrong Function Resolved" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-34092" CVSS="7.5">
    <Description>Vite provides frontend tooling. Prior to versions 2.9.16, 3.2.7, 4.0.5, 4.1.5, 4.2.3, and 4.3.9, Vite Server Options (`server.fs.deny`) can be bypassed using double forward-slash (//) allows any unauthenticated user to read file from the Vite root-path of the application including the default `fs.deny` settings (`['.env', '.env.*', '*.{crt,pem}']`). Only users explicitly exposing the Vite dev server to the network (using `--host` or `server.host` config option) are affected, and only files in the immediate Vite project root folder could be exposed. This issue is fixed in vite@4.3.9, vite@4.2.3, vite@4.1.5, vite@4.0.5, vite@3.2.7, and vite@2.9.16.</Description>
    <URL>https://github.com/vitejs/vite/commit/813ddd6155c3d54801e264ba832d8347f6f66b32</URL>
    <CWE CWE="50">
      <MainWeakness Cause="Under-Restrictive Policy" Operation="Sanitize" Consequence="File Injection" />
    </CWE>
    <CWE CWE="706">
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Object Resolved" />
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Function Resolved" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-34453" CVSS="7.5">
    <Description>snappy-java is a fast compressor/decompressor for Java. Due to unchecked multiplications, an integer overflow may occur in versions prior to 1.1.10.1, causing a fatal error.

The function `shuffle(int[] input)` in the file `BitShuffle.java` receives an array of integers and applies a bit shuffle on it. It does so by multiplying the length by 4 and passing it to the natively compiled shuffle function. Since the length is not tested, the multiplication by four can cause an integer overflow and become a smaller value than the true size, or even zero or negative. In the case of a negative value, a `java.lang.NegativeArraySizeException` exception will raise, which can crash the program. In a case of a value that is zero or too small, the code that afterwards references the shuffled array will assume a bigger size of the array, which might cause exceptions such as `java.lang.ArrayIndexOutOfBoundsException`.

The same issue exists also when using the `shuffle` functions that receive a double, float, long and short, each using a different multiplier that may cause the same issue.

Version 1.1.10.1 contains a patch for this vulnerability.</Description>
    <URL>https://github.com/xerial/snappy-java/commit/820e2e074c58748b41dbd547f4edba9e108ad905</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-34454" CVSS="7.5">
    <Description>snappy-java is a fast compressor/decompressor for Java. Due to unchecked multiplications, an integer overflow may occur in versions prior to 1.1.10.1, causing an unrecoverable fatal error.

The function `compress(char[] input)` in the file `Snappy.java` receives an array of characters and compresses it. It does so by multiplying the length by 2 and passing it to the rawCompress` function.

Since the length is not tested, the multiplication by two can cause an integer overflow and become negative. The rawCompress function then uses the received length and passes it to the natively compiled maxCompressedLength function, using the returned value to allocate a byte array.

Since the maxCompressedLength function treats the length as an unsigned integer, it doesn’t care that it is negative, and it returns a valid value, which is casted to a signed integer by the Java engine. If the result is negative, a `java.lang.NegativeArraySizeException` exception will be raised while trying to allocate the array `buf`. On the other side, if the result is positive, the `buf` array will successfully be allocated, but its size might be too small to use for the compression, causing a fatal Access Violation error.

The same issue exists also when using the `compress` functions that receive double, float, int, long and short, each using a different multiplier that may cause the same issue. The issue most likely won’t occur when using a byte array, since creating a byte array of size 0x80000000 (or any other negative value) is impossible in the first place.

Version 1.1.10.1 contains a patch for this issue.</Description>
    <URL>https://github.com/xerial/snappy-java/commit/d0042551e4a3509a725038eb9b2ad1f683674d94</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-36326" CVSS="9.8">
    <Description>Integer Overflow vulnerability in RELIC before commit 34580d840469361ba9b5f001361cad659687b9ab, allows attackers to execute arbitrary code, cause a denial of service, and escalate privileges when calling realloc function in bn_grow function.</Description>
    <URL>https://github.com/relic-toolkit/relic/commit/34580d840469361ba9b5f001361cad659687b9ab</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-36327" CVSS="9.8">
    <Description>Integer Overflow vulnerability in RELIC before commit 421f2e91cf2ba42473d4d54daf24e295679e290e, allows attackers to execute arbitrary code and cause a denial of service in pos argument in bn_get_prime function.</Description>
    <URL>https://github.com/relic-toolkit/relic/commit/421f2e91cf2ba42473d4d54daf24e295679e290e</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-3635" CVSS="7.5">
    <Description>GzipSource does not handle an exception that might be raised when parsing a malformed gzip buffer. This may lead to denial of service of the Okio client when handling a crafted GZIP archive, by using the GzipSource class.

</Description>
    <URL>https://github.com/square/okio/commit/81bce1a30af244550b0324597720e4799281da7b</URL>
    <CWE CWE="195">
      <MainWeakness Cause="Erroneous Code" Operation="Coerce" Consequence="Wrong Value" />
    </CWE>
    <CWE CWE="681">
      <MainWeakness Operation="Coerce" Consequence="Distorted Value" />
      <MainWeakness Operation="Coerce" Consequence="Rounded Value" />
      <MainWeakness Operation="Coerce" Consequence="Truncated Value" />
      <MainWeakness Operation="Coerce" Consequence="Flipped Sign" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-36829" CVSS="5.4">
    <Description>Sentry is an error tracking and performance monitoring platform. Starting in version 23.6.0 and prior to version 23.6.2, the Sentry API incorrectly returns the `access-control-allow-credentials: true` HTTP header if the `Origin` request header ends with the `system.base-hostname` option of Sentry installation. This only affects installations that have `system.base-hostname` option explicitly set, as it is empty by default. Impact is limited since recent versions of major browsers have cross-site cookie blocking enabled by default. However, this flaw could allow other multi-step attacks. The patch has been released in Sentry 23.6.2.</Description>
    <URL>https://github.com/getsentry/sentry/commit/ee44c6be35e5e464bc40637580f39867898acd8b</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-38403" CVSS="7.5">
    <Description>iperf3 before 3.14 allows peers to cause an integer overflow and heap corruption via a crafted length field.</Description>
    <URL>https://github.com/esnet/iperf/commit/0ef151550d96cc4460f98832df84b4a1e87c65e9</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-38427" CVSS="9.8">
    <Description>An issue was discovered in the Linux kernel before 6.3.8. fs/smb/server/smb2pdu.c in ksmbd has an integer underflow and out-of-bounds read in deassemble_neg_contexts.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/fs/smb/server?id=f1a411873c85b642f13b01f21b534c2bab81fc1b</URL>
    <CWE CWE="125">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Read" Consequence="Buffer Over-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Read" Consequence="Buffer Under-Read">
        <OtherWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
        <OtherWeakness Cause="Wrong Index" Operation="Reposition" Consequence="Over Bounds Pointer/Under Bounds Pointer" />
      </MainWeakness>
    </CWE>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-38429" CVSS="9.8">
    <Description>An issue was discovered in the Linux kernel before 6.3.4. fs/ksmbd/connection.c in ksmbd has an off-by-one error in memory allocation (because of ksmbd_smb2_check_message) that may lead to out-of-bounds access.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/fs/ksmbd?id=443d61d1fa9faa60ef925513d83742902390100f</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-38698" CVSS="6.5">
    <Description>Ethereum Name Service (ENS) is a distributed, open, and extensible naming system based on the Ethereum blockchain. According to the documentation, controllers are allowed to register new domains and extend the expiry of existing domains, but they cannot change the ownership or reduce the expiration time of existing domains. However, a preliminary analysis suggests that an attacker-controlled controller may be able to reduce the expiration time of existing domains due to an integer overflow in the renew function. The vulnerability resides `@ensdomains/ens-contracts` prior to version 0.0.22.

If successfully exploited, this vulnerability would enable attackers to force the expiration of any ENS record, ultimately allowing them to claim the affected domains for themselves. Currently, it would require a malicious DAO to exploit it. Nevertheless, any vulnerability present in the controllers could potentially render this issue exploitable in the future. An additional concern is the possibility of renewal discounts. Should ENS decide to implement a system that offers unlimited .eth domains for a fixed fee in the future, the vulnerability could become exploitable by any user due to the reduced attack cost.

Version 0.0.22 contains a patch for this issue. As long as registration cost remains linear or superlinear based on registration duration, or limited to a reasonable maximum (eg, 1 million years), this vulnerability could only be exploited by a malicious DAO. The interim workaround is thus to take no action.
</Description>
    <URL>https://github.com/ensdomains/ens-contracts/commit/e6b136e979084de3761c125142620304173990ca</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-39350" CVSS="7.5">
    <Description>FreeRDP is a free implementation of the Remote Desktop Protocol (RDP), released under the Apache license. This issue affects Clients only. Integer underflow leading to DOS (e.g. abort due to `WINPR_ASSERT` with default compilation flags). When an insufficient blockLen is provided, and proper length validation is not performed, an Integer Underflow occurs, leading to a Denial of Service (DOS) vulnerability. This issue has been addressed in versions 2.11.0 and 3.0.0-beta3. Users are advised to upgrade. There are no known workarounds for this vulnerability.
</Description>
    <URL>https://github.com/FreeRDP/FreeRDP/commit/e204fc8be5a372626b13f66daf2abafe71dbc2dc</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-40022" CVSS="7.8">
    <Description>Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.6.0 and prior are vulnerable to integer overflow in `consume_count` of `src/gnu_v2/cplus-dem.c`. The overflow check is valid logic but, is missing the modulus if the block once compiled. The compiler sees this block as unreachable code since the prior statement is multiplication by 10 and fails to consider overflow assuming the count will always be a multiple of 10. Rizin version 0.6.1 contains a fix for the issue. A temporary workaround would be disabling C++ demangling using the configuration option `bin.demangle=false`.</Description>
    <URL>https://github.com/rizinorg/rz-libdemangle/commit/51d016750e704b27ab8ace23c0f72acabca67018</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-41880" CVSS="5.3">
    <Description>Wasmtime is a standalone runtime for WebAssembly. Wasmtime versions from 10.0.0 to versions 10.02, 11.0.2, and 12.0.1 contain a miscompilation of the WebAssembly `i64x2.shr_s` instruction on x86_64 platforms when the shift amount is a constant value that is larger than 32. Only x86_64 is affected so all other targets are not affected by this. The miscompilation results in the instruction producing an incorrect result, namely the low 32-bits of the second lane of the vector are derived from the low 32-bits of the second lane of the input vector instead of the high 32-bits. The primary impact of this issue is that any WebAssembly program using the `i64x2.shr_s` with a constant shift amount larger than 32 may produce an incorrect result.

This issue is not an escape from the WebAssembly sandbox. Execution of WebAssembly guest programs will still behave correctly with respect to memory sandboxing and isolation from the host. Wasmtime considers non-spec-compliant behavior as a security issue nonetheless.

This issue was discovered through fuzzing of Wasmtime's code generator Cranelift.

Wasmtime versions 10.0.2, 11.0.2, and 12.0.2 are all patched to no longer have this miscompilation. This issue only affects x86_64 hosts and the only workaround is to either scan for this pattern in wasm modules which is nontrivial or to disable the SIMD proposal for WebAssembly. Users prior to 10.0.0 are unaffected by this vulnerability.</Description>
    <URL>https://github.com/bytecodealliance/wasmtime/commit/8d7eda15b0badcbea83a7aac2d08f80788b59240</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-42451" CVSS="7.5">
    <Description>Mastodon is a free, open-source social network server based on ActivityPub. Prior to versions 3.5.14, 4.0.10, 4.1.8, and 4.2.0-rc2, under certain circumstances, attackers can exploit a flaw in domain name normalization to spoof domains they do not own. Versions 3.5.14, 4.0.10, 4.1.8, and 4.2.0-rc2 contain a patch for this issue.</Description>
    <URL>https://github.com/mastodon/mastodon/commit/eeab3560fc0516070b3fb97e089b15ecab1938c8</URL>
    <CWE CWE="706">
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Object Resolved" />
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Function Resolved" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-42467" CVSS="5.5">
    <Description>QEMU through 8.0.0 could trigger a division by zero in scsi_disk_reset in hw/scsi/scsi-disk.c because scsi_disk_emulate_mode_select does not prevent s-&gt;qdev.blocksize from being 256. This stops QEMU and the guest immediately.</Description>
    <URL>https://gitlab.com/qemu-project/qemu/-/commit/7cfcc79b0ab800959716738aff9419f53fc68c9c</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-42752" CVSS="5.5">
    <Description>An integer overflow flaw was found in the Linux kernel. This issue leads to the kernel allocating `skb_shared_info` in the userspace, which is exploitable in systems without SMAP protection since `skb_shared_info` contains references to function pointers.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=915d975b2ffa</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-44378" CVSS="5.5">
    <Description>gnark is a zk-SNARK library that offers a high-level API to design circuits. Prior to version 0.9.0, for some in-circuit values, it is possible to construct two valid decomposition to bits. In addition to the canonical decomposition of `a`, for small values there exists a second decomposition for `a+r` (where `r` is the modulus the values are being reduced by). The second decomposition was possible due to overflowing the field where the values are defined. Upgrading to version 0.9.0 should fix the issue without needing to change the calls to value comparison methods.</Description>
    <URL>https://github.com/Consensys/gnark/commit/59a4087261a6c73f13e80d695c17b398c3d0934f</URL>
    <CWE CWE="191">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-45133" CVSS="8.8">
    <Description>Babel is a compiler for writingJavaScript. In `@babel/traverse` prior to versions 7.23.2 and 8.0.0-alpha.4 and all versions of `babel-traverse`, using Babel to compile code that was specifically crafted by an attacker can lead to arbitrary code execution during compilation, when using plugins that rely on the `path.evaluate()`or `path.evaluateTruthy()` internal Babel methods. Known affected plugins are `@babel/plugin-transform-runtime`; `@babel/preset-env` when using its `useBuiltIns` option; and any "polyfill provider" plugin that depends on `@babel/helper-define-polyfill-provider`, such as `babel-plugin-polyfill-corejs3`, `babel-plugin-polyfill-corejs2`, `babel-plugin-polyfill-es-shims`, `babel-plugin-polyfill-regenerator`. No other plugins under the `@babel/` namespace are impacted, but third-party plugins might be. Users that only compile trusted code are not impacted. The vulnerability has been fixed in `@babel/traverse@7.23.2` and `@babel/traverse@8.0.0-alpha.4`. Those who cannot upgrade `@babel/traverse` and are using one of the affected packages mentioned above should upgrade them to their latest version to avoid triggering the vulnerable code path in affected `@babel/traverse` versions: `@babel/plugin-transform-runtime` v7.23.2, `@babel/preset-env` v7.23.2, `@babel/helper-define-polyfill-provider` v0.4.3, `babel-plugin-polyfill-corejs2` v0.4.6, `babel-plugin-polyfill-corejs3` v0.8.5, `babel-plugin-polyfill-es-shims` v0.10.0, `babel-plugin-polyfill-regenerator` v0.5.3.</Description>
    <URL>https://github.com/babel/babel/commit/b13376b346946e3f62fc0848c1d2a23223314c82</URL>
    <CWE CWE="184">
      <MainWeakness Cause="Under-Restrictive Policy" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Under-Restrictive Policy" Operation="Validate" Consequence="Invalid Data" />
    </CWE>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-45871" CVSS="7.5">
    <Description>An issue was discovered in drivers/net/ethernet/intel/igb/igb_main.c in the IGB driver in the Linux kernel before 6.5.3. A buffer size may not be adequate for frames larger than the MTU.</Description>
    <URL>https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=bb5ed01cd2428cd25b1c88a3a9cba87055eb289f</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-46228" CVSS="7.8">
    <Description>zchunk before 1.3.2 has multiple integer overflows via malformed zchunk files to lib/comp/comp.c, lib/comp/zstd/zstd.c, lib/dl/multipart.c, or lib/header.c.</Description>
    <URL>https://github.com/zchunk/zchunk/commit/08aec2b4dfd7f709b6e3d511411ffcc83ed4efbe</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-46232" CVSS="5.3">
    <Description>era-compiler-vyper is the EraVM Vyper compiler for zkSync Era, a layer 2 rollup that uses zero-knowledge proofs to scale Ethereum. Prior to era-compiler-vype version 1.3.10, a bug prevented the initialization of the first immutable variable for Vyper contracts meeting certain criteria. The problem arises when there is a String or Array with more 256-bit words allocated than initialized. It results in the second word’s index unset, that is effectively set to 0, so the first immutable value with the actual 0 index is overwritten in the ImmutableSimulator. Version 1.3.10 fixes this issue by setting all indexes in advance. The problem will go away, but it will get more expensive if the user allocates a lot of uninitialized space, e.g. `String[4096]`. Upgrading and redeploying affected contracts is the only way of working around the issue.
</Description>
    <URL>https://github.com/matter-labs/era-compiler-vyper/commit/8be305a1b9c68d0fd47dad3434224ed85944ca25</URL>
    <CWE CWE="471">
      <MainWeakness Cause="Erroneous Code" Operation="Declare" Consequence="Wrong Access Object" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-46246" CVSS="5.5">
    <Description>Vim is an improved version of the good old UNIX editor Vi. Heap-use-after-free in memory allocated in the function `ga_grow_inner` in in the file `src/alloc.c` at line 748, which is freed in the file `src/ex_docmd.c` in the function `do_cmdline` at line 1010 and then used again in `src/cmdhist.c` at line 759. When using the `:history` command, it's possible that the provided argument overflows the accepted value. Causing an Integer Overflow and potentially later an use-after-free. This vulnerability has been patched in version 9.0.2068.
</Description>
    <URL>https://github.com/vim/vim/commit/9198c1f2b1ddecde22af918541e0de2a32f0f45a</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <CWE CWE="416">
      <MainWeakness Cause="Dangling Pointer" Operation="Read" Consequence="Use After Deallocate" />
      <MainWeakness Cause="Dangling Pointer" Operation="Write" Consequence="Use After Deallocate" />
      <MainWeakness Cause="Dangling Pointer" Operation="Dereference" Consequence="Use After Deallocate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-46247" CVSS="7.5">
    <Description>Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). Contracts containing large arrays might underallocate the number of slots they need by 1. Prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`. The intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. Roughly speaking, if `type_.size_in_bytes` is large (&gt; 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed by 1. If `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed by 1. This issue is patched in version 0.3.8.</Description>
    <URL>https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <CWE CWE="682">
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrap Around" />
      <MainWeakness Cause="Erroneous Code" Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-4678" CVSS="5.5">
    <Description>Divide By Zero in GitHub repository gpac/gpac prior to 2.3-DEV.</Description>
    <URL>https://github.com/gpac/gpac/commit/4607052c482a51dbdacfe1ade10645c181d07b07</URL>
    <CWE CWE="369">
      <MainWeakness Cause="Wrong Argument" Operation="Calculate" Consequence="Undefined">
        <OtherWeakness Cause="Missing Code/Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      </MainWeakness>
    </CWE>
    <Failure Comment="via Division by Zero">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-46853" CVSS="9.8">
    <Description>In Memcached before 1.6.22, an off-by-one error exists when processing proxy requests in proxy mode, if \n is used instead of \r\n.</Description>
    <URL>https://github.com/memcached/memcached/commit/6987918e9a3094ec4fc8976f01f769f624d790fa</URL>
    <CWE CWE="193">
      <MainWeakness Operation="Calculate" Consequence="Wrong Result" />
    </CWE>
    <Failure Comment="via Off-by-One">Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2023-4720" CVSS="5.5">
    <Description>Floating Point Comparison with Incorrect Operator in GitHub repository gpac/gpac prior to 2.3-DEV.</Description>
    <URL>https://github.com/gpac/gpac/commit/e396648e48c57e2d53988d3fd4465b068b96c89a</URL>
    <CWE CWE="1077">
      <MainWeakness Operation="Evaluate" Consequence="Wrong Result" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-4722" CVSS="5.5">
    <Description>Integer Overflow or Wraparound in GitHub repository gpac/gpac prior to 2.3-DEV.</Description>
    <URL>https://github.com/gpac/gpac/commit/de7f3a852bef72a52825fd307cf4e8f486401a76</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-4734" CVSS="7.8">
    <Description>Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.1846.</Description>
    <URL>https://github.com/vim/vim/commit/4c6fe2e2ea62469642ed1d80b16d39e616b25cf5</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-48233" CVSS="4.3">
    <Description>Vim is an open source command line text editor. If the count after the :s command is larger than what fits into a (signed) long variable, abort with e_value_too_large. Impact is low, user interaction is required and a crash may not even happen in all situations. This issue has been addressed in commit `ac6378773` which has been included in release version 9.0.2108. Users are advised to upgrade. There are no known workarounds for this vulnerability.</Description>
    <URL>https://github.com/vim/vim/commit/ac63787734fda2e294e477af52b3bd601517fa78</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-48234" CVSS="4.3">
    <Description>Vim is an open source command line text editor. When getting the count for a normal mode z command, it may overflow for large counts given. Impact is low, user interaction is required and a crash may not even happen in all situations. This issue has been addressed in commit `58f9befca1` which has been included in release version 9.0.2109. Users are advised to upgrade. There are no known workarounds for this vulnerability.</Description>
    <URL>https://github.com/vim/vim/commit/58f9befca1fa172068effad7f2ea5a9d6a7b0cca</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-48235" CVSS="4.3">
    <Description>Vim is an open source command line text editor. When parsing relative ex addresses one may unintentionally cause an
overflow. Ironically this happens in the existing overflow check, because the line number becomes negative and LONG_MAX - lnum will cause the overflow. Impact is low, user interaction is required and a crash may not even happen in all situations. This issue has been addressed in commit `060623e` which has been included in release version 9.0.2110. Users are advised to upgrade. There are no known workarounds for this vulnerability.</Description>
    <URL>https://github.com/vim/vim/commit/060623e4a3bc72b011e7cd92bedb3bfb64e06200</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-48236" CVSS="4.3">
    <Description>Vim is an open source command line text editor. When using the z= command, the user may overflow the count with values larger
than MAX_INT. Impact is low, user interaction is required and a crash may not even happen in all situations. This vulnerability has been addressed in commit `73b2d379` which has been included in release version 9.0.2111. Users are advised to upgrade. There are no known workarounds for this vulnerability.</Description>
    <URL>https://github.com/vim/vim/commit/73b2d3790cad5694fc0ed0db2926e4220c48d968</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-48237" CVSS="4.3">
    <Description>Vim is an open source command line text editor. In affected versions when shifting lines in operator pending mode and using a very large value, it may be possible to overflow the size of integer. Impact is low, user interaction is required and a crash may not even happen in all situations. This issue has been addressed in commit `6bf131888` which has been included in version 9.0.2112. Users are advised to upgrade. There are no known workarounds for this vulnerability.</Description>
    <URL>https://github.com/vim/vim/commit/6bf131888a3d1de62bbfa8a7ea03c0ddccfd496e</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-52557">
    <Description>In OpenBSD 7.3 before errata 016, npppd(8) could crash by a l2tp message which has an AVP (Attribute-Value Pair) with wrong length.
</Description>
    <URL>https://github.com/openbsd/src/commit/abf3a29384c582c807a621e7fc6e7c68d0cafe9b</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-52558">
    <Description>In OpenBSD 7.4 before errata 002 and OpenBSD 7.3 before errata 019, a network buffer that had to be split at certain length that could crash the kernel after receiving specially crafted escape sequences.</Description>
    <URL>https://github.com/openbsd/src/commit/7b4d35e0a60ba1dd4daf4b1c2932020a22463a89</URL>
    <CWE CWE="131">
      <MainWeakness Operation="Calculate" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2023-6478" CVSS="7.5">
    <Description>A flaw was found in xorg-server. A specially crafted request to RRChangeProviderProperty or RRChangeOutputProperty can trigger an integer overflow which may lead to a disclosure of sensitive information.</Description>
    <URL>https://gitlab.freedesktop.org/xorg/xserver/-/commit/14f480010a93ff962fef66a16412fafff81ad632</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2024-21631" CVSS="6.5">
    <Description>Vapor is an HTTP web framework for Swift. Prior to version 4.90.0, Vapor's `vapor_urlparser_parse` function uses `uint16_t` indexes when parsing a URI's components, which may cause integer overflows when parsing untrusted inputs. This vulnerability does not affect Vapor directly but could impact applications relying on the URI type for validating user input. The URI type is used in several places in Vapor. A developer may decide to use URI to represent a URL in their application (especially if that URL is then passed to the HTTP Client) and rely on its public properties and methods. However, URI may fail to properly parse a valid (albeit abnormally long) URL, due to string ranges being converted to 16-bit integers. An attacker may use this behavior to trick the application into accepting a URL to an untrusted destination. By padding the port number with zeros, an attacker can cause an integer overflow to occur when the URL authority is parsed and, as a result, spoof the host. Version 4.90.0 contains a patch for this issue. As a workaround, validate user input before parsing as a URI or, if possible, use Foundation's `URL` and `URLComponents` utilities.
</Description>
    <URL>https://github.com/vapor/vapor/commit/6db3d917b5ce5024a84eb265ef65691383305d70</URL>
    <CWE CWE="20">
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Validate" Consequence="Invalid Data" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Type" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Wrong Value" />
      <MainWeakness Cause="Missing Code" Operation="Verify" Consequence="Incosnistent Value" />
      <MainWeakness Cause="Erroneous Code" Operation="Verify" Consequence="Wrong Type" />
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2024-21646" CVSS="9.8">
    <Description>Azure uAMQP is a general purpose C library for AMQP 1.0. The UAMQP library is used by several clients to implement AMQP protocol communication.  When clients using this library receive a crafted binary type data, an integer overflow or wraparound or memory safety issue can occur and may cause remote code execution.  This vulnerability has been patched in release 2024-01-01.</Description>
    <URL>https://github.com/Azure/azure-uamqp-c/commit/12ddb3a31a5a97f55b06fa5d74c59a1d84ad78fe</URL>
    <CWE CWE="94">
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Source Code Injection" />
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Source Code Injection" />
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2024-22051" CVSS="9.8">
    <Description>CommonMarker versions prior to 0.23.4 are at risk of an integer overflow vulnerability. This vulnerability can result in possibly unauthenticated remote attackers to cause heap memory corruption, potentially leading to an information leak or remote code execution, via parsing tables with marker rows that contain more than UINT16_MAX columns.

</Description>
    <URL>https://github.com/gjtorikian/commonmarker/commit/ab4504fd17460627a6ab255bc3c63e8e5fc6aed3</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Remote Code Execution (RCE)">Arbitrary Code Execution (ACE)</Failure>
    <Failure Comment="via Memory Corruption">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2024-22211" CVSS="9.8">
    <Description>FreeRDP is a set of free and open source remote desktop protocol library and clients. In affected versions an integer overflow in `freerdp_bitmap_planar_context_reset` leads to heap-buffer overflow. This affects FreeRDP based clients. FreeRDP based server implementations and proxy are not affected. A malicious server could prepare a `RDPGFX_RESET_GRAPHICS_PDU` to allocate too small buffers, possibly triggering later out of bound read/write. Data extraction over network is not possible, the buffers are used to display an image. This issue has been addressed in version 2.11.5 and 3.2.0. Users are advised to upgrade. there are no know workarounds for this vulnerability.
</Description>
    <URL>https://github.com/FreeRDP/FreeRDP/commit/939e922936e9c3ae8fc204968645e5e7563a2fff</URL>
    <CWE CWE="122">
      <MainWeakness Cause="Over Bounds Pointer" Operation="Write" Consequence="Buffer Overflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
      <MainWeakness Cause="Under Bounds Pointer" Operation="Write" Consequence="Buffer Underflow">
        <OperandAttribute Name="Address" Type="State">Heap</OperandAttribute>
      </MainWeakness>
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via Buffer Overflow">Data Tempering (TPR)</Failure>
  </CVE>
  <CVE CVE="CVE-2024-22860" CVSS="9.8">
    <Description>Integer overflow vulnerability in FFmpeg before n6.1, allows remote attackers to execute arbitrary code via the jpegxl_anim_read_packet component in the JPEG XL Animation decoder.</Description>
    <URL>https://github.com/FFmpeg/FFmpeg/commit/d2e8974699a9e35cc1a926bf74a972300d629cd5</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2024-22861" CVSS="7.5">
    <Description>Integer overflow vulnerability in FFmpeg before n6.1, allows attackers to cause a denial of service (DoS) via the avcodec/osq module.</Description>
    <URL>https://github.com/FFmpeg/FFmpeg/commit/87b8c1081959e45ffdcbabb3d53ac9882ef2b5ce</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Denial of Service (DoS)</Failure>
  </CVE>
  <CVE CVE="CVE-2024-22862" CVSS="9.8">
    <Description>Integer overflow vulnerability in FFmpeg before n6.1, allows remote attackers to execute arbitrary code via the JJPEG XL Parser.</Description>
    <URL>https://github.com/FFmpeg/FFmpeg/commit/ca09d8a0dcd82e3128e62463231296aaf63ae6f7</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure>Arbitrary Code Execution (ACE)</Failure>
  </CVE>
  <CVE CVE="CVE-2024-27101" CVSS="7.3">
    <Description>SpiceDB is an open source, Google Zanzibar-inspired database for creating and managing security-critical application permissions. Integer overflow in chunking helper causes dispatching to miss elements or panic.  Any SpiceDB cluster with any schema where a resource being checked has more than 65535 relationships for the same resource and subject type is affected by this problem.  The CheckPermission, BulkCheckPermission, and LookupSubjects API methods are affected. This vulnerability is fixed in 1.29.2.</Description>
    <URL>https://github.com/authzed/spicedb/commit/ef443c442b96909694390324a99849b0407007fe</URL>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2024-27292" CVSS="7.5">
    <Description>Docassemble is an expert system for guided interviews and document assembly. The vulnerability allows attackers to gain unauthorized access to information on the system through URL manipulation. It affects versions 1.4.53 to 1.4.96. The vulnerability has been patched in version 1.4.97 of the master branch.</Description>
    <URL>https://github.com/jhpyle/docassemble/commit/97f77dc486a26a22ba804765bfd7058aabd600c9</URL>
    <CWE CWE="706">
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Object Resolved" />
      <MainWeakness Cause="Erroneous Code" Operation="Refer" Consequence="Wrong Function Resolved" />
    </CWE>
    <Failure />
  </CVE>
  <CVE CVE="CVE-2024-27304" CVSS="9.8">
    <Description>pgx is a PostgreSQL driver and toolkit for Go. SQL injection can occur if an attacker can cause a single query or bind message to exceed 4 GB in size. An integer overflow in the calculated message size can cause the one large message to be sent as multiple messages under the attacker's control. The problem is resolved in v4.18.2 and v5.5.4. As a workaround, reject user input large enough to cause a single query or bind message to exceed 4 GB in size.</Description>
    <URL>https://github.com/jackc/pgproto3/commit/945c2126f6db8f3bea7eeebe307c01fe92bca007</URL>
    <CWE CWE="89">
      <MainWeakness Cause="Erroneous Code" Operation="Sanitize" Consequence="Query Injection" />
      <MainWeakness Cause="Missing Code" Operation="Sanitize" Consequence="Query Injection" />
    </CWE>
    <CWE CWE="190">
      <MainWeakness Operation="Calculate" Consequence="Wrap Around" />
    </CWE>
    <Failure Comment="via SQL Injection">Data Tempering (TPR)</Failure>
    <Failure Comment="via SQL Injection">Information Exposure (IEX)</Failure>
  </CVE>
  <CVE CVE="CVE-2024-29026" CVSS="8.2">
    <Description>Owncast is an open source, self-hosted, decentralized, single user live video streaming and chat server. In versions 0.1.2 and prior, a lenient CORS policy allows attackers to make a cross origin request, reading privileged information. This can be used to leak the admin password. Commit 9215d9ba0f29d62201d3feea9e77dcd274581624 fixes this issue.</Description>
    <URL>https://github.com/owncast/owncast/commit/9215d9ba0f29d62201d3feea9e77dcd274581624</URL>
    <CWE CWE="697">
      <MainWeakness Cause="Erroneous Code" Operation="Evaluate" />
    </CWE>
    <Failure />
  </CVE>
</BFCVE_DAT-partial>